attacking passwords, let's take a moment to discuss authentication and its components.
\\authentication
Authentication
Authentication, at its core, is the validation of your identity by presenting a combination of four factors to a validation mechanism. They are:

Something you know: a password, passcode, pin, etc.
Something you have: an ID Card, security key, or other MFA tools
Something you are: your physical self, username, email address, or other identifiers
Somewhere you are: geolocation, IP address, etc.
\\The use of passwords
https://haveibeenpwned.com/
Passwords are commonly hashed when stored, in order to provide some protection in the event they fall into the hands of an attacker. Hashing is a mathematical function which transforms an arbitrary number of input bytes into a (typically) fixed-size output; common examples of hash functions are MD5, and SHA-256.
Take the password Soccer06! for example. The corresponding MD5 and SHA-256 hashes can be generated with the following commands:
$echo -n Soccer06! | md5sum
$echo -n Soeccer06! | sha256sum
Hash functions are designed to work in one direction. This means it should not be possible to figure out what the original password was based on the hash alon
Common techniques are to use rainbow tables, to perform dictionary attacks, and typically as a last resort, to perform brute-force attacks.
\\Rainbow Tables
Rainbow tables are large pre-compiled maps of input and output values for a given hash functio used to very quickly identify the password if its corresponding hash has already been mapped.
Password	MD5 Hash
123456	e10adc3949ba59abbe56e057f20f883e
12345	827ccb0eea8a706c4c34a16891f84e7b

Because rainbow tables are such a powerful attack, salting is used. A salt, in cryptographic terms, is a random sequence of bytes added to a password before it is hashed
To maximize impact, salts should not be reused, e.g. for all passwords stored in one database. For example, if the salt Th1sIsTh3S@lt_ is prepended to the same password, the MD5 hash would now be as follows:
$echo -n Th1sIsTh3S@lt_Soccer06! | md5sum
A salt is not a secret value — when a system goes to check an authentication request  it needs to know what salt was used so that it can check if the password hash matches For this reason, salts are typically prepended to corresponding hashes.
- To make rainbow tables effective again, an attacker would need to update their mapping to account for every possible salt. A salt consisting of just one single byte would mean the 15 billion entries from before would have to be 3.84 trillion (factor of 256).
\\Brute-force attack
A brute-force attack involves attempting every possible combination of letters, numbers, and symbols until the correct password is discovered. Obviously, this can take a very long time—especially for long passwords—however shorter passwords (<9 characters) are viable targets, even on consumer hardware. Brute-forcing is the only password cracking technique that is 100% effective -
Brute-force attempt	MD5 Hash
...SNIP...	...SNIP...
Sxejd	2cdc813ef26e6d20c854adb107279338

Note: Brute-forcing speeds depend heavily on the hashing algorithm and hardware that is used. On a typical company laptop, a tool like hashcat might be able to guess over five million passwords per second when attacking MD5, while at the same time only managing ten thousand per second when targeting a DCC2 hash.
\\Dictionary attack
A dictionary attack, otherwise known as a wordlist attack, is one of the most efficient techniques for cracking passwords, especially when operating under time-constraints as penetration testers usually do. Rather than attempting every possible combination of characters, a list containing statistically likely passwords is used. Well-known wordlists for password cracking are rockyou.txt and those included in SecLists.
kinlingit@htb[/htb]$ head --lines=20 /usr/share/wordlists/rockyou.txt 
\\==================================
Introduct to John the Ripper
als jtr aka john is a well-known pentest tool used for cracking password through various atk including brute-force and dictionary. 
-the jumbo variant is recomemend for performance optimizations, additionla feature such as multingual wordlist, 64-bit architecture.
carcker the greater password and accuracy and speed . 
\\Cracking modes 
Single crack mode is  e is a rule-based cracking technique that is most useful when targeting Linux credentials. It generates password candidates based on the victim's username, home directory name, and GECOS values (full name, room number, phone number, etc.). T
Note: The Linux authentication process, as well as cracking rules, will be covered in-depth in later sections. The following example is simplified for demonstration purposes.
EX: Imagine we as attackers came across the file passwd with the following contents:
r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash
Based on the contents of the file, it can be inferred that the victim has the username r0lf, the real name Rolf Sebastian, and the home directory /home/r0lf. Single crack mode will use this information to generate candidate passwords and test them against the hash. We can run the attack with the following command:
$john --single passwd
\\Wordlist mode
ordlist mode is used to crack passwords with a dictionary attack, meaning it attempts all passwords in a supplied wordlist against the password hash. The basic syntax for the command is as follows:
$john --wordlist=<wordlist_file> <hash_file> 
--rules argumen for generate candidate password more widely
The wordlist file (or files) used for cracking password hashes must be in plain text format, with one word per line. Multiple wordlists can be specified by separating them with a comma. Rules, either custom or built-in, can be specified by using the --rules argument. 
\\Incremental mode
Incremental mode is a powerful, brute-force-style password cracking mode that generates candidate passwords based on a statistical model (Markov chains). It is designed to test all character combinations defined by a specific character set, prioritizing more likely passwords based on training data.
https://en.wikipedia.org/wiki/Markov_chain
This mode is the most exhaustive, but also the most time-consuming. It generates password guesses dynamically and does not rely on a predefined wordlist, in contrast to wordlist mode. Unlike purely random brute-force attacks, Incremental mode uses a statistical model to make educated guesses, resulting in a significantly more efficient approach than naïve brute-force attacks.
$john --incremental <hash_file>
You can customize these or define your own to target passwords that use special characters or specific patterns.
\\creating our owwn password wordlist
$grep '# Incremental mod' -A 100 /etc/john/john.conf 
Note: This mode can be resource-intensive and slow, especially for long or complex passwords. Customizing the character set and length can improve performance and focus the attack.
\\Identifying hash formats
https://openwall.info/wiki/john/sample-hashes
https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats
Both sources list multiple example hashes as well as the corresponding JtR format
https://github.com/psypanda/hashID  By adding the -j flag, hashID will, in addition to the hash format, list the corresponding JtR format:
$hashid -j 193069ceb0461e1d40d216e32c79c704  -> unclear result
JtR supports hundreds of hash formats, some of which are listed in the table below. The --format argument can be supplied to instruct JtR which format target hashes have.
$john --format
\\Cracking files
It is also possible to crack password-protected or encrypted files with JtR. Multiple "2john" tools come with JtR that can be used to process files and produce hashes compatible with JtR. The generalized syntax for these tools is:
$<tool like rar2john> <file to crack> > file.hash to get hash
$locate *2john*
<test>Use single-crack mode to crack r0lf's password.
echo -n 'r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash' > hash.txt
john --single hash.txt
<test>Use wordlist-mode with rockyou.txt to crack the RIPEMD-128 password.
echo -n '193069ceb0461e1d40d216e32c79c704' > hash.txt tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
john --wordlist=<wordlist_file> <hash_file> 
john --format=ripemd-128 --wordlist=./rockyou.txt hash.txt >cat ~/.john/john.pot | grep <hash>
\\=====================================
Introduction to Hashcat
Hashcat is a well-known password cracking tool for Linux, Windows, and macOS. From 2009 until 2015 it was proprietary software, but has since been released as open-source. Featuring fantastic GPU support, it can be used to crack a large variety of hashes. Similar to JtR, hashcat supports multiple attack (cracking) modes which can be used to efficiently attack password hashes.
$hashcat -a 0 -m 0 <hashes> [wordlist, rule, mask, ....]
-a is specify the atk mode    -m is specify the hash type   <hashes>either a hash string or a file containing one or more password hashes of the same type
[wordlist, rule, mask ] is placeholder for additional arguments that depend of the atk mode
\\Hash types
Hashcat supports hundreds of different hash types, each of which is assigned a ID. A list of associated IDs can be generated by running hashcat --help.
$hashcat --help
The hashcat website hosts a comprehensive list of example hashes which can assist in manually identifying an unknown hash type and determining the corresponding Hashcat hash mode identifier.
https://hashcat.net/wiki/doku.php?id=example_hashes
https://github.com/psypanda/hashID can be used to quickly identify the hashcat hash type by specifying the -m argument.
$hashid -m '$1$FNr44XZC$wQxY6HHLrgrGX0e1195k.1'
\\Attack modes
Hashcat has many different attack mode, including dictionary, mask, combinator, and association. In this section we will go over the first two, as they are likely the most common ones that you will need to use.
\\Dictionary attack
Dictionary attack (-a 0) is, as the name suggests, a dictionary attack. The user provides password hashes and a wordlist as input, and Hashcat tests each word in the list as a potential password until the correct one is found or the list is exhausted.
EX:As an example, imagine we extracted the following password hash from an SQL database: e3e3ec5831ad5e7288241960e5d4fdb8. First, we could identify this as an MD5 hash, which has a hash ID of 0. To attempt to crack this hash using the rockyou.txt wordlist, the following command would be used:
$hashcat -a 0 -m 0 e3e3ec5831ad5e7288241960e5d4fdb8 /usr/share/wordlists/rockyou.txt
A wordlist alone is often not enough to crack a password hash. As was the case with JtR, rules can be used to perform specific modifications to passwords to generate even more guesses. The rule files that come with hashcat are typically found under /usr/share/hashcat/rules:
$ls /usr/share/hashcat/rules
As another example, imagine an additional md5 hash was leaked from the SQL database: 1b0556a75770563578569ae21392630c. We weren't able to crack it using rockyou.txt alone, so in a subsequent attempt, we might apply some common rule-based transformations. One ruleset we could try is best64.rule, which contains 64 standard password modifications—such as appending numbers or substituting characters with their "leet" equivalents. To perform this kind of attack, we would append the -r <ruleset> option to the command, as shown below
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
\\Mask Attack
(-a 3) is a type of brute-force atk  attack in which the keyspace is explicitly defined by the user
example, if we know that a password is eight characters long, rather than attempting every possible combination, we might define a mask that tests combinations of six letters followed by two numbers.
A mask is defined by combining a sequence of symbols, each representing a built-in or custom character set. Hashcat includes several built-in character sets:
Symbol	Charset
?l	abcdefghijklmnopqrstuvwxyz
?u	ABCDEFGHIJKLMNOPQRSTUVWXYZ
?d	0123456789
?h	0123456789abcdef
?H	0123456789ABCDEF
?s	«space»!"#$%&'()*+,-./:;<=>?@[]^_`{
?a	?l?u?d?s
?b	0x00 - 0xff
Custom charsets can be defined with the -1, -2, -3, and -4 arguments, then referred to with ?1, ?2, ?3, and ?4.
Let's say that we specifically want to try passwords which start with an uppercase letter, continue with four lowercase letters, a digit, and then a symbol. The resulting hashcat mask would be ?u?l?l?l?l?d?s.
$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
<test>Use a dictionary attack to crack the first password hash. (Hash: e3e3ec5831ad5e7288241960e5d4fdb8)
tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
$hashcat -a 0 -m 0 <hash> ./rockyou.txt

Use a dictionary attack with rules to crack the second password hash. (Hash: 1b0556a75770563578569ae21392630c)
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c ./rockyou.txt -r /usr/share/hashcat/rules/best64.rule
Use a mask attack to crack the third password hash. (Hash: 1e293d6912d074c0fd15844d803400dd)

$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
\\=================================================
Writing Custom Wordlists and RUles
Many users create their passwords based on simplicity rather than security
Basic OSINT (Open Source Intelligence) techniques can be highly effective in uncovering such personal information and may assist in password guessing. More information about OSINT can be found in the OSINT: Corporate Recon module.
https://hashcat.net/wiki/doku.php?id=rule_based_attack
cat custom.rule
:	Do nothing
l	Lowercase all letters
u	Uppercase all letters
c	Capitalize the first letter and lowercase others
sXY	Replace all instances of X with Y
$!	Add the exclamation character at the end
$hashcat --force password.list -r custom.rule -r custom.rule --stdout | sort -u > mut_password.list
Hashcat and JtR both come with pre-built rule lists that can be used for password generation and cracking. One of the most effective and widely used rulesets is best64.rule
We can narrow this down and perform more targeted guessing if we have information about the password policy, while considering factors such as the company name, geographical region, industry, and other topics or keywords that users might choose when creating their passwords. Exceptions, of course, include cases where passwords have been leaked and directly obtained.
\\Generating wordlists using CeWL
$cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist
$wc -l inlane.wordlist
\\Exercise
For this sections exercise, imagine that we compromised the password hash of a work email belonging to Mark White. After performing a bit of OSINT, we have gathered the following information about Mark:

He was born on August 5, 1998
He works at Nexura, Ltd.
The company's password policy requires passwords to be at least 12 characters long, to contain at least one uppercase letter, at least one lowercase letter, at least one symbol and at least one number
He lives in San Francisco, CA, USA
He has a pet cat named Bella
He has a wife named Maria
He has a son named Alex
He is a big fan of baseball

97268a8ae45ac7d15c3cea4ce6ea550b
$create a password list
$create a rule
run the hashcat with password list and rule
$hashcat -a 3 -m 0 <password-list> -r <rule.rule>
$hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
cat << EOF > password.list
Mark
White
August
1998
Nexura
Sanfrancisco
California
Bella
Maria
Alex
Baseball
EOF
$cat << EOF > custom.rule
c
C
t
\$!
\$1\$9\$9\$8
\$1\$9\$9\$8\$!
sa@
so0
ss\$
EOF

hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
c - Capitalize the first character, lowercase the rest C - Lowercase the first character, uppercase the rest t - Toggle the case of all characters in a word $! - Appends the character ! to the end $1$9$9$8 - Appends '1998' to the end $1$9$9$8$! - Appends '1998!' to the end sa@ - Replace all instances of a with @ so0 - Replace all instances of o with 0 ss$ - Replace all instances of s with $
mask attack
$hashcat -a 0 -m 0 97268a8ae45ac7d15c3cea4ce6ea550b mut_password.list
\\\\\\\\\\==========================================
Cracking Protected files
The use of file encryption is often neglected in both private and professional contexts. Even today, emails containing job applications, account statements, or contracts are frequently sent without encryption—sometimes in violation of legal regulations. For example, within the European Union, the General Data Protection Regulation (GDPR) requires that personal data be encrypted both in transit and at rest. Nevertheless, it remains standard practice to discuss confidential topics or transmit sensitive data via email, which may be intercepted by attackers positioned to exploit these communication channels
\\Hunting for Encrypted files
Many different extensions correspond to encrypted files—a useful reference list can be found on FileInfo. As an example, consider this command we might use to locate commonly encrypted files on a Linux system:
https://fileinfo.com/filetypes/encoded
$ for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
\\Hunting for SSH keys
$ grep -rnE '^\-{5}BEGIN [A-Z0-9]+ PRIVATE KEY\-{5}$' /* 2>/dev/null
$ cat /home/jsmith/.ssh/SSH.private
One way to tell whether an SSH key is encrypted or not, is to try reading the key with ssh-keygen.
$ ssh-keygen -yf ~/.ssh/id_ed25519 
As shown below, attempting to read a password-protected SSH key will prompt the user for a passphrase:
\\Cracking encrypted SSH keys
$ locate *2john*
$ ssh2john.py SSH.private > ssh.hash
$ john --wordlist=rockyou.txt ssh.hash  > $ john ssh.hash --show
\\Cracking password-protected documents
$office2john.py Protected.docx > protected-docx.hash
$john --wordlist=rockyou.txt protected-docx.hash
$john protected-docx.hash --show
\\Cracking Protected Archives

